{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"makefun \u00b6 Dynamically create python functions with a proper signature. New remove_args parameter in @wraps . See below for details ! makefun helps you create functions dynamically, with the signature of your choice. It was largely inspired by decorator and functools , and created mainly to cover some of their limitations. The typical use cases are: creating signature-preserving function wrappers - just like functools.wraps but with accurate TypeError exception raising when user-provided arguments are wrong, and with a very convenient way to access argument values. creating function wrappers that have more or less arguments that the function they wrap. A bit like functools.partial but a lot more flexible and friendly for your users. For example, I use it in my pytest plugins to add a requests parameter to users' tests or fixtures when they do not already have it. more generally, creating functions with a signature derived from a reference signature , or even creating functions with a signature completely defined at runtime . It currently supports three ways to define the signature of the created function from a given reference function, e.g. foo . from strings, e.g. 'foo(a, b=1)' from Signature objects, either manually created, or obtained by using the inspect.signature (or its backport funcsigs.signature ) method. creating signature-preserving decorators Creating decorators and creating signature-preserving function wrappers are two independent problems. makefun is solely focused on the second problem. If you wish to solve the first problem you can look at decopatch . It provides a compact syntax, relying on makefun , if you wish to tackle both at once. Installing \u00b6 > pip install makefun Usage \u00b6 1- Ex-nihilo creation \u00b6 Let's create a function foo(b, a=0) implemented by func_impl . The easiest way to provide the signature is as a str : from makefun import create_function # (1) define the signature. Warning: do not put 'def' keyword here! func_sig = \"foo(b, a=0)\" # (2) define the function implementation def func_impl ( * args , ** kwargs ): \"\"\"This docstring will be used in the generated function by default\"\"\" print ( \"func_impl called !\" ) return args , kwargs # (3) create the dynamic function gen_func = create_function ( func_sig , func_impl ) We can test it: >>> args , kwargs = gen_func ( 2 ) func_impl called ! >>> assert args == () >>> assert kwargs == { 'a' : 0 , 'b' : 2 } You can also: remove the name from the signature string (e.g. '(b, a=0)' ) to directly use the function name of func_impl . override the function name, docstring, qualname and module name if you pass a non-None func_name , doc , qualname and module_name argument add other attributes on the generated function if you pass additional keyword arguments See API reference for details. Arguments mapping \u00b6 We can see above that args is empty, even if we called gen_func with a positional argument. This is completely normal: this is because the created function does not expose (*args, **kwargs) but exposes the desired signature (b, a=0) . So as for usual python function calls, we lose the information about what was provided as positional and what was provided as keyword. You can try it yourself: write a function def foo(b, a=0) and now try to guess from the function body what was provided as positional, and what was provided as keyword... This behaviour is actually a great feature because it makes it much easier to develop the func_impl ! Indeed, except if your desired signature contains positional-only (not yet available as of python 3.7) or var-positional (e.g. *args ) arguments, you will always find all named arguments in **kwargs . More compact syntax \u00b6 You can use the @with_signature decorator to perform exactly the same things than create_function , but in a more compact way: from makefun import with_signature @with_signature ( \"foo(b, a=0)\" ) def gen_func ( * args , ** kwargs ): \"\"\"This docstring will be used in the generated function by default\"\"\" print ( \"func_impl called !\" ) return args , kwargs It also has the capability to take None as a signature, if you just want to update the metadata ( func_name , doc , qualname , module_name ) without creating any function: @with_signature ( None , func_name = 'f' ) def foo ( a ): return a assert foo . __name__ == 'f' See API reference for details. PEP484 type hints in str \u00b6 PEP484 type hints are supported in string function definitions: func_sig = \"foo(b: int, a: float = 0) -> str\" PEP484 type comments are also supported: func_signature = \"\"\" foo(b, # type: int a = 0, # type: float ): # type: (...) -> str \"\"\" but unfortunately inspect.signature is not able to detect them so the generated function does not contain the annotations. See this example . Using Signature objects \u00b6 create_function and @with_signature are able to accept a Signature object as input, instead of a str . That might be more convenient than using strings to programmatically define signatures. For example we can rewrite the above script using Signature : from makefun import with_signature from inspect import Signature , Parameter # (1) define the signature using objects. parameters = [ Parameter ( 'b' , kind = Parameter . POSITIONAL_OR_KEYWORD ), Parameter ( 'a' , kind = Parameter . POSITIONAL_OR_KEYWORD , default = 0 ), ] func_sig = Signature ( parameters ) func_name = 'foo' # (2) define the function @with_signature ( func_sig , func_name = func_name ) def gen_func ( * args , ** kwargs ): \"\"\"This docstring will be used in the generated function by default\"\"\" print ( \"func_impl called !\" ) return args , kwargs Note that Signature objects do not contain any function name information. You therefore have to provide an explicit func_name argument to @with_signature (or to create_function ) as shown above. Signature availability in python 2 In python 2 the inspect package does not provide any signature-related features, but a complete backport is available: funcsigs . 2- Deriving from existing signatures \u00b6 In many real-world applications we want to reuse \"as is\", or slightly modify, an existing signature. Copying a signature \u00b6 If you just want to expose the same signature as a reference function (and not wrap it nor appear like it), the easiest way to copy the signature from another function f is to use signature(f) from inspect / funcsigs . Signature-preserving function wrappers \u00b6 @functools.wraps is a famous decorator to create \"signature-preserving\" function wrappers. However it does not actually preserve the signature, it just uses a trick (setting the __wrapped__ attribute) to trigger special dedicated behaviour in stdlib 's help() and signature() methods. See here . This has two major limitations: the wrapper code will execute even when the provided arguments are invalid . the wrapper code can not easily access an argument using its name, from the received *args, **kwargs . Indeed one would have to handle all cases (positional, keyword, default) and therefore to use something like Signature.bind() . makefun provides a convenient replacement for @wraps that fixes these two issues: from makefun import wraps # a dummy function def foo ( a , b = 1 ): \"\"\" foo doc \"\"\" return a + b # our signature-preserving wrapper @wraps ( foo ) def enhanced_foo ( * args , ** kwargs ): print ( 'hello!' ) print ( 'b= %s ' % kwargs [ 'b' ]) # we can reliably access 'b' return foo ( * args , ** kwargs ) We can check that the wrapper behaves correctly whatever the call modes: >>> assert enhanced_foo ( 1 , 2 ) == 3 # positional 'b' hello ! b = 2 >>> assert enhanced_foo ( b = 0 , a = 1 ) == 1 # keyword 'b' hello ! b = 0 >>> assert enhanced_foo ( 1 ) == 2 # default 'b' hello ! b = 1 And let's pass wrong arguments to it: we see that the wrapper is not executed. >>> enhanced_foo () TypeError : foo () missing 1 required positional argument : 'a' You can try to do the same experiment with functools.wraps to see the difference. Finally note that a create_wrapper function is also provided for convenience ; it is the equivalent of @wraps but as a standard function - not a decorator. creating signature-preserving decorators Creating decorators and creating signature-preserving function wrappers are two independent problems. makefun is solely focused on the second problem. If you wish to solve the first problem you can look at decopatch . It provides a compact syntax, relying on makefun , if you wish to tackle both at once. Editing a signature \u00b6 Below we show how to add a parameter to a function. We first capture its Signature using inspect.signature(f) , we modify it to add a parameter, and finally we use it in wraps to create our final function: from makefun import wraps from inspect import signature , Parameter # (0) the reference function def foo ( b , a = 0 ): print ( \"foo called: b= %s , a= %s \" % ( b , a )) return b , a # (1a) capture the signature of reference function `foo` foo_sig = signature ( foo ) print ( \"Original Signature: %s \" % foo_sig ) # (1b) modify the signature to add a new parameter 'z' as first argument params = list ( foo_sig . parameters . values ()) params . insert ( 0 , Parameter ( 'z' , kind = Parameter . POSITIONAL_OR_KEYWORD )) new_sig = foo_sig . replace ( parameters = params ) print ( \"New Signature: %s \" % new_sig ) # (2) define the wrapper implementation @wraps ( foo , new_sig = new_sig ) def foo_wrapper ( z , * args , ** kwargs ): print ( \"foo_wrapper called ! z= %s \" % z ) # call the foo function output = foo ( * args , ** kwargs ) # return augmented output return z , output # call it assert foo_wrapper ( 3 , 2 ) == 3 , ( 2 , 0 ) yields Original Signature: (b, a=0) New Signature: (z, b, a=0) foo_wrapper called ! z=3 foo called: b=2, a=0 This way you can therefore easily create function wrappers with different signatures: not only adding, but also removing parameters, changing their kind (forcing keyword-only for example), etc. The possibilities are as endless as the capabilities of the Signature objects. Two helper functions are provided in this toolbox to make it a bit easier for you to edit Signature objects: remove_signature_parameters creates a new signature from an existing one by removing all parameters corresponding to the names provided add_signature_parameters prepends the Parameter s provided in its first= argument, and appends the ones provided in its last argument. from makefun import add_signature_parameters , remove_signature_parameters def foo ( b , c , a = 0 ): pass # original signature foo_sig = signature ( foo ) print ( \"original signature: %s \" % foo_sig ) # let's modify it new_sig = add_signature_parameters ( foo_sig , first = Parameter ( 'z' , kind = Parameter . POSITIONAL_OR_KEYWORD ), last = Parameter ( 'o' , kind = Parameter . POSITIONAL_OR_KEYWORD , default = True ) ) new_sig = remove_signature_parameters ( new_sig , 'b' , 'a' ) print ( \"modified signature: %s \" % new_sig ) yields original signature: ( b, c, a = 0 ) modified signature: ( z, c, o = True ) They might save you a few lines of code if your use-case is not too specific. Removing parameters easily \u00b6 To replace them with a hardcoded value \u00b6 As goodies, makefun provides a partial function that are equivalent to functools.partial , except that it is fully signature-preserving and modifies the documentation with a nice helper message explaining that this is a partial view: def foo ( x , y ): \"\"\" a `foo` function :param x: :param y: :return: \"\"\" return x + y from makefun import partial bar = partial ( foo , x = 12 ) we can test it: >>> assert bar ( 1 ) == 13 >>> help ( bar ) Help on function bar in module makefun . tests . test_partial_and_macros : bar ( y ) < This function is equivalent to 'foo(y, x=12)' , see original 'foo' doc below .> a ` foo ` function : param x : : param y : : return : A @with_partial decorator is also available to create partial views easily for quick tests: @with_partial ( x = 12 ) def foo ( x , y ): \"\"\" a `foo` function :param x: :param y: :return: \"\"\" return x + y To inject a dynamically baked value \u00b6 @wraps now provides a remove_args parameter where you can pass one or several argument names. def inject_random_a ( f ): \"\"\" A decorator that injects a random number inside the `a` argument, removing it from the exposed signature \"\"\" @wraps ( f , remove_args = 'a' ) def my_wrapper ( * args , ** kwargs ): # generate a random value for a and inject it in the args for f kwargs [ 'a' ] = random () return f ( * args , ** kwargs ) return my_wrapper @inject_random_a def summer ( a , b ): return a + b assert 12 <= summer ( b = 12 ) <= 13 3- Advanced topics \u00b6 Generators and Coroutines \u00b6 create_function and @with_signature will automatically create a generator if your implementation is a generator: # define the implementation def my_generator_impl ( b , a = 0 ): for i in range ( a , b ): yield i * i # create the dynamic function gen_func = create_function ( \"foo(a, b)\" , my_generator_impl ) # verify that the new function is a generator and behaves as such assert isgeneratorfunction ( gen_func ) assert list ( gen_func ( 1 , 4 )) == [ 1 , 4 , 9 ] The same goes for generator-based coroutines: # define the impl that should be called def my_gencoroutine_impl ( first_msg ): second_msg = ( yield first_msg ) yield second_msg # create the dynamic function gen_func = create_function ( \"foo(first_msg='hello')\" , my_gencoroutine_impl ) # verify that the new func is a generator-based coroutine and behaves correctly cor = gen_func ( 'hi' ) assert next ( cor ) == 'hi' assert cor . send ( 'chaps' ) == 'chaps' cor . send ( 'ola' ) # raises StopIteration and asyncio coroutines as well # define the impl that should be called async def my_native_coroutine_impl ( sleep_time ): await sleep ( sleep_time ) return sleep_time # create the dynamic function gen_func = create_function ( \"foo(sleep_time=2)\" , my_native_coroutine_impl ) # verify that the new function is a native coroutine and behaves correctly from asyncio import get_event_loop out = get_event_loop () . run_until_complete ( gen_func ( 5 )) assert out == 5 Generated source code \u00b6 The generated source code is in the __source__ field of the generated function: print ( gen_func . __source__ ) prints the following source code: def foo ( b , a = 0 ): return _func_impl_ ( b = b , a = a ) The _func_impl_ symbol represents your implementation. As already mentioned , you see that the variables are passed to it as keyword arguments when possible ( _func_impl_(b=b) , not simply _func_impl_(b) ). Of course if it is not possible it adapts: gen_func = create_function ( \"foo(a=0, *args, **kwargs)\" , func_impl ) print ( gen_func . __source__ ) prints the following source code: def foo ( a = 0 , * args , ** kwargs ): return _func_impl_ ( a = a , * args , ** kwargs ) Function reference injection \u00b6 In some scenarios you may wish to share the same implementation among several created functions, for example to expose slightly different signatures on top of the same core. In that case you may wish your implementation to know from which dynamically generated function it is being called. For this, simply use inject_as_first_arg=True , and the called function will be injected as the first argument: def core_impl ( f , * args , ** kwargs ): print ( \"This is generic core called by %s \" % f . __name__ ) # here you could use f.__name__ in a if statement to determine what to do if f . __name__ == \"func1\" : print ( \"called from func1 !\" ) return args , kwargs # generate 2 functions func1 = create_function ( \"func1(a, b)\" , core_impl , inject_as_first_arg = True ) func2 = create_function ( \"func2(a, d)\" , core_impl , inject_as_first_arg = True ) func1 ( 1 , 2 ) func2 ( 1 , 2 ) yields This is generic core called by func1 called from func1 ! This is generic core called by func2 4. Other goodies \u00b6 @compile_fun \u00b6 A draft decorator to compile any existing function so that users cant debug through it. It can be handy to mask some code from your users for convenience (note that this does not provide any obfuscation, people can still reverse engineer your code easily. Actually the source code even gets copied in the function's __source__ attribute for convenience): from makefun import compile_fun @compile_fun def foo ( a , b ): return a + b assert foo ( 5 , - 5.0 ) == 0 print ( foo . __source__ ) yields @compile_fun def foo(a, b): return a + b If the function closure includes functions, they are recursively replaced with compiled versions too (only for this closure, this does not modify them otherwise). You may disable this behaviour entirely with recurse=False , or exclude some symbols from this recursion with the except_names=(...) arg (a tuple of names to exclude). IMPORTANT this decorator is a \"goodie\" in early stage and has not been extensively tested. Feel free to contribute ! Note that according to this post compiling does not make the code run any faster. Known issues: NameError may appear if your function code depends on symbols that have not yet been defined. Make sure all symbols exist first ! See this issue . Main features / benefits \u00b6 Generate functions with a dynamically defined signature : the signature can be provided as a string or as a Signature object, thus making it handy to derive from other functions. Implement them easily : the generated functions redirect their calls to the provided implementation function. As long as the signature is compliant, it will work as expected. For example the signature can be specific ( a: int, b=None ), and the implementation more generic ( *args, **kwargs ). Arguments will always be passed as keywords arguments when possible. Replace `@functools.wraps so that it correctly preserves signatures, and enable you to easily access named arguments. See Also \u00b6 decorator , which largely inspired this code PEP362 - Function Signature Object A blog entry on dynamic function creation functools.wraps Others \u00b6 Do you like this library ? You might also like my other python libraries Want to contribute ? \u00b6 Details on the github page: https://github.com/smarie/python-makefun","title":"Home"},{"location":"#makefun","text":"Dynamically create python functions with a proper signature. New remove_args parameter in @wraps . See below for details ! makefun helps you create functions dynamically, with the signature of your choice. It was largely inspired by decorator and functools , and created mainly to cover some of their limitations. The typical use cases are: creating signature-preserving function wrappers - just like functools.wraps but with accurate TypeError exception raising when user-provided arguments are wrong, and with a very convenient way to access argument values. creating function wrappers that have more or less arguments that the function they wrap. A bit like functools.partial but a lot more flexible and friendly for your users. For example, I use it in my pytest plugins to add a requests parameter to users' tests or fixtures when they do not already have it. more generally, creating functions with a signature derived from a reference signature , or even creating functions with a signature completely defined at runtime . It currently supports three ways to define the signature of the created function from a given reference function, e.g. foo . from strings, e.g. 'foo(a, b=1)' from Signature objects, either manually created, or obtained by using the inspect.signature (or its backport funcsigs.signature ) method. creating signature-preserving decorators Creating decorators and creating signature-preserving function wrappers are two independent problems. makefun is solely focused on the second problem. If you wish to solve the first problem you can look at decopatch . It provides a compact syntax, relying on makefun , if you wish to tackle both at once.","title":"makefun"},{"location":"#installing","text":"> pip install makefun","title":"Installing"},{"location":"#usage","text":"","title":"Usage"},{"location":"#1-ex-nihilo-creation","text":"Let's create a function foo(b, a=0) implemented by func_impl . The easiest way to provide the signature is as a str : from makefun import create_function # (1) define the signature. Warning: do not put 'def' keyword here! func_sig = \"foo(b, a=0)\" # (2) define the function implementation def func_impl ( * args , ** kwargs ): \"\"\"This docstring will be used in the generated function by default\"\"\" print ( \"func_impl called !\" ) return args , kwargs # (3) create the dynamic function gen_func = create_function ( func_sig , func_impl ) We can test it: >>> args , kwargs = gen_func ( 2 ) func_impl called ! >>> assert args == () >>> assert kwargs == { 'a' : 0 , 'b' : 2 } You can also: remove the name from the signature string (e.g. '(b, a=0)' ) to directly use the function name of func_impl . override the function name, docstring, qualname and module name if you pass a non-None func_name , doc , qualname and module_name argument add other attributes on the generated function if you pass additional keyword arguments See API reference for details.","title":"1- Ex-nihilo creation"},{"location":"#arguments-mapping","text":"We can see above that args is empty, even if we called gen_func with a positional argument. This is completely normal: this is because the created function does not expose (*args, **kwargs) but exposes the desired signature (b, a=0) . So as for usual python function calls, we lose the information about what was provided as positional and what was provided as keyword. You can try it yourself: write a function def foo(b, a=0) and now try to guess from the function body what was provided as positional, and what was provided as keyword... This behaviour is actually a great feature because it makes it much easier to develop the func_impl ! Indeed, except if your desired signature contains positional-only (not yet available as of python 3.7) or var-positional (e.g. *args ) arguments, you will always find all named arguments in **kwargs .","title":"Arguments mapping"},{"location":"#more-compact-syntax","text":"You can use the @with_signature decorator to perform exactly the same things than create_function , but in a more compact way: from makefun import with_signature @with_signature ( \"foo(b, a=0)\" ) def gen_func ( * args , ** kwargs ): \"\"\"This docstring will be used in the generated function by default\"\"\" print ( \"func_impl called !\" ) return args , kwargs It also has the capability to take None as a signature, if you just want to update the metadata ( func_name , doc , qualname , module_name ) without creating any function: @with_signature ( None , func_name = 'f' ) def foo ( a ): return a assert foo . __name__ == 'f' See API reference for details.","title":"More compact syntax"},{"location":"#pep484-type-hints-in-str","text":"PEP484 type hints are supported in string function definitions: func_sig = \"foo(b: int, a: float = 0) -> str\" PEP484 type comments are also supported: func_signature = \"\"\" foo(b, # type: int a = 0, # type: float ): # type: (...) -> str \"\"\" but unfortunately inspect.signature is not able to detect them so the generated function does not contain the annotations. See this example .","title":"PEP484 type hints in str"},{"location":"#using-signature-objects","text":"create_function and @with_signature are able to accept a Signature object as input, instead of a str . That might be more convenient than using strings to programmatically define signatures. For example we can rewrite the above script using Signature : from makefun import with_signature from inspect import Signature , Parameter # (1) define the signature using objects. parameters = [ Parameter ( 'b' , kind = Parameter . POSITIONAL_OR_KEYWORD ), Parameter ( 'a' , kind = Parameter . POSITIONAL_OR_KEYWORD , default = 0 ), ] func_sig = Signature ( parameters ) func_name = 'foo' # (2) define the function @with_signature ( func_sig , func_name = func_name ) def gen_func ( * args , ** kwargs ): \"\"\"This docstring will be used in the generated function by default\"\"\" print ( \"func_impl called !\" ) return args , kwargs Note that Signature objects do not contain any function name information. You therefore have to provide an explicit func_name argument to @with_signature (or to create_function ) as shown above. Signature availability in python 2 In python 2 the inspect package does not provide any signature-related features, but a complete backport is available: funcsigs .","title":"Using Signature objects"},{"location":"#2-deriving-from-existing-signatures","text":"In many real-world applications we want to reuse \"as is\", or slightly modify, an existing signature.","title":"2- Deriving from existing signatures"},{"location":"#copying-a-signature","text":"If you just want to expose the same signature as a reference function (and not wrap it nor appear like it), the easiest way to copy the signature from another function f is to use signature(f) from inspect / funcsigs .","title":"Copying a signature"},{"location":"#signature-preserving-function-wrappers","text":"@functools.wraps is a famous decorator to create \"signature-preserving\" function wrappers. However it does not actually preserve the signature, it just uses a trick (setting the __wrapped__ attribute) to trigger special dedicated behaviour in stdlib 's help() and signature() methods. See here . This has two major limitations: the wrapper code will execute even when the provided arguments are invalid . the wrapper code can not easily access an argument using its name, from the received *args, **kwargs . Indeed one would have to handle all cases (positional, keyword, default) and therefore to use something like Signature.bind() . makefun provides a convenient replacement for @wraps that fixes these two issues: from makefun import wraps # a dummy function def foo ( a , b = 1 ): \"\"\" foo doc \"\"\" return a + b # our signature-preserving wrapper @wraps ( foo ) def enhanced_foo ( * args , ** kwargs ): print ( 'hello!' ) print ( 'b= %s ' % kwargs [ 'b' ]) # we can reliably access 'b' return foo ( * args , ** kwargs ) We can check that the wrapper behaves correctly whatever the call modes: >>> assert enhanced_foo ( 1 , 2 ) == 3 # positional 'b' hello ! b = 2 >>> assert enhanced_foo ( b = 0 , a = 1 ) == 1 # keyword 'b' hello ! b = 0 >>> assert enhanced_foo ( 1 ) == 2 # default 'b' hello ! b = 1 And let's pass wrong arguments to it: we see that the wrapper is not executed. >>> enhanced_foo () TypeError : foo () missing 1 required positional argument : 'a' You can try to do the same experiment with functools.wraps to see the difference. Finally note that a create_wrapper function is also provided for convenience ; it is the equivalent of @wraps but as a standard function - not a decorator. creating signature-preserving decorators Creating decorators and creating signature-preserving function wrappers are two independent problems. makefun is solely focused on the second problem. If you wish to solve the first problem you can look at decopatch . It provides a compact syntax, relying on makefun , if you wish to tackle both at once.","title":"Signature-preserving function wrappers"},{"location":"#editing-a-signature","text":"Below we show how to add a parameter to a function. We first capture its Signature using inspect.signature(f) , we modify it to add a parameter, and finally we use it in wraps to create our final function: from makefun import wraps from inspect import signature , Parameter # (0) the reference function def foo ( b , a = 0 ): print ( \"foo called: b= %s , a= %s \" % ( b , a )) return b , a # (1a) capture the signature of reference function `foo` foo_sig = signature ( foo ) print ( \"Original Signature: %s \" % foo_sig ) # (1b) modify the signature to add a new parameter 'z' as first argument params = list ( foo_sig . parameters . values ()) params . insert ( 0 , Parameter ( 'z' , kind = Parameter . POSITIONAL_OR_KEYWORD )) new_sig = foo_sig . replace ( parameters = params ) print ( \"New Signature: %s \" % new_sig ) # (2) define the wrapper implementation @wraps ( foo , new_sig = new_sig ) def foo_wrapper ( z , * args , ** kwargs ): print ( \"foo_wrapper called ! z= %s \" % z ) # call the foo function output = foo ( * args , ** kwargs ) # return augmented output return z , output # call it assert foo_wrapper ( 3 , 2 ) == 3 , ( 2 , 0 ) yields Original Signature: (b, a=0) New Signature: (z, b, a=0) foo_wrapper called ! z=3 foo called: b=2, a=0 This way you can therefore easily create function wrappers with different signatures: not only adding, but also removing parameters, changing their kind (forcing keyword-only for example), etc. The possibilities are as endless as the capabilities of the Signature objects. Two helper functions are provided in this toolbox to make it a bit easier for you to edit Signature objects: remove_signature_parameters creates a new signature from an existing one by removing all parameters corresponding to the names provided add_signature_parameters prepends the Parameter s provided in its first= argument, and appends the ones provided in its last argument. from makefun import add_signature_parameters , remove_signature_parameters def foo ( b , c , a = 0 ): pass # original signature foo_sig = signature ( foo ) print ( \"original signature: %s \" % foo_sig ) # let's modify it new_sig = add_signature_parameters ( foo_sig , first = Parameter ( 'z' , kind = Parameter . POSITIONAL_OR_KEYWORD ), last = Parameter ( 'o' , kind = Parameter . POSITIONAL_OR_KEYWORD , default = True ) ) new_sig = remove_signature_parameters ( new_sig , 'b' , 'a' ) print ( \"modified signature: %s \" % new_sig ) yields original signature: ( b, c, a = 0 ) modified signature: ( z, c, o = True ) They might save you a few lines of code if your use-case is not too specific.","title":"Editing a signature"},{"location":"#removing-parameters-easily","text":"","title":"Removing parameters easily"},{"location":"#to-replace-them-with-a-hardcoded-value","text":"As goodies, makefun provides a partial function that are equivalent to functools.partial , except that it is fully signature-preserving and modifies the documentation with a nice helper message explaining that this is a partial view: def foo ( x , y ): \"\"\" a `foo` function :param x: :param y: :return: \"\"\" return x + y from makefun import partial bar = partial ( foo , x = 12 ) we can test it: >>> assert bar ( 1 ) == 13 >>> help ( bar ) Help on function bar in module makefun . tests . test_partial_and_macros : bar ( y ) < This function is equivalent to 'foo(y, x=12)' , see original 'foo' doc below .> a ` foo ` function : param x : : param y : : return : A @with_partial decorator is also available to create partial views easily for quick tests: @with_partial ( x = 12 ) def foo ( x , y ): \"\"\" a `foo` function :param x: :param y: :return: \"\"\" return x + y","title":"To replace them with a hardcoded value"},{"location":"#to-inject-a-dynamically-baked-value","text":"@wraps now provides a remove_args parameter where you can pass one or several argument names. def inject_random_a ( f ): \"\"\" A decorator that injects a random number inside the `a` argument, removing it from the exposed signature \"\"\" @wraps ( f , remove_args = 'a' ) def my_wrapper ( * args , ** kwargs ): # generate a random value for a and inject it in the args for f kwargs [ 'a' ] = random () return f ( * args , ** kwargs ) return my_wrapper @inject_random_a def summer ( a , b ): return a + b assert 12 <= summer ( b = 12 ) <= 13","title":"To inject a dynamically baked value"},{"location":"#3-advanced-topics","text":"","title":"3- Advanced topics"},{"location":"#generators-and-coroutines","text":"create_function and @with_signature will automatically create a generator if your implementation is a generator: # define the implementation def my_generator_impl ( b , a = 0 ): for i in range ( a , b ): yield i * i # create the dynamic function gen_func = create_function ( \"foo(a, b)\" , my_generator_impl ) # verify that the new function is a generator and behaves as such assert isgeneratorfunction ( gen_func ) assert list ( gen_func ( 1 , 4 )) == [ 1 , 4 , 9 ] The same goes for generator-based coroutines: # define the impl that should be called def my_gencoroutine_impl ( first_msg ): second_msg = ( yield first_msg ) yield second_msg # create the dynamic function gen_func = create_function ( \"foo(first_msg='hello')\" , my_gencoroutine_impl ) # verify that the new func is a generator-based coroutine and behaves correctly cor = gen_func ( 'hi' ) assert next ( cor ) == 'hi' assert cor . send ( 'chaps' ) == 'chaps' cor . send ( 'ola' ) # raises StopIteration and asyncio coroutines as well # define the impl that should be called async def my_native_coroutine_impl ( sleep_time ): await sleep ( sleep_time ) return sleep_time # create the dynamic function gen_func = create_function ( \"foo(sleep_time=2)\" , my_native_coroutine_impl ) # verify that the new function is a native coroutine and behaves correctly from asyncio import get_event_loop out = get_event_loop () . run_until_complete ( gen_func ( 5 )) assert out == 5","title":"Generators and Coroutines"},{"location":"#generated-source-code","text":"The generated source code is in the __source__ field of the generated function: print ( gen_func . __source__ ) prints the following source code: def foo ( b , a = 0 ): return _func_impl_ ( b = b , a = a ) The _func_impl_ symbol represents your implementation. As already mentioned , you see that the variables are passed to it as keyword arguments when possible ( _func_impl_(b=b) , not simply _func_impl_(b) ). Of course if it is not possible it adapts: gen_func = create_function ( \"foo(a=0, *args, **kwargs)\" , func_impl ) print ( gen_func . __source__ ) prints the following source code: def foo ( a = 0 , * args , ** kwargs ): return _func_impl_ ( a = a , * args , ** kwargs )","title":"Generated source code"},{"location":"#function-reference-injection","text":"In some scenarios you may wish to share the same implementation among several created functions, for example to expose slightly different signatures on top of the same core. In that case you may wish your implementation to know from which dynamically generated function it is being called. For this, simply use inject_as_first_arg=True , and the called function will be injected as the first argument: def core_impl ( f , * args , ** kwargs ): print ( \"This is generic core called by %s \" % f . __name__ ) # here you could use f.__name__ in a if statement to determine what to do if f . __name__ == \"func1\" : print ( \"called from func1 !\" ) return args , kwargs # generate 2 functions func1 = create_function ( \"func1(a, b)\" , core_impl , inject_as_first_arg = True ) func2 = create_function ( \"func2(a, d)\" , core_impl , inject_as_first_arg = True ) func1 ( 1 , 2 ) func2 ( 1 , 2 ) yields This is generic core called by func1 called from func1 ! This is generic core called by func2","title":"Function reference injection"},{"location":"#4-other-goodies","text":"","title":"4. Other goodies"},{"location":"#compile_fun","text":"A draft decorator to compile any existing function so that users cant debug through it. It can be handy to mask some code from your users for convenience (note that this does not provide any obfuscation, people can still reverse engineer your code easily. Actually the source code even gets copied in the function's __source__ attribute for convenience): from makefun import compile_fun @compile_fun def foo ( a , b ): return a + b assert foo ( 5 , - 5.0 ) == 0 print ( foo . __source__ ) yields @compile_fun def foo(a, b): return a + b If the function closure includes functions, they are recursively replaced with compiled versions too (only for this closure, this does not modify them otherwise). You may disable this behaviour entirely with recurse=False , or exclude some symbols from this recursion with the except_names=(...) arg (a tuple of names to exclude). IMPORTANT this decorator is a \"goodie\" in early stage and has not been extensively tested. Feel free to contribute ! Note that according to this post compiling does not make the code run any faster. Known issues: NameError may appear if your function code depends on symbols that have not yet been defined. Make sure all symbols exist first ! See this issue .","title":"@compile_fun"},{"location":"#main-features-benefits","text":"Generate functions with a dynamically defined signature : the signature can be provided as a string or as a Signature object, thus making it handy to derive from other functions. Implement them easily : the generated functions redirect their calls to the provided implementation function. As long as the signature is compliant, it will work as expected. For example the signature can be specific ( a: int, b=None ), and the implementation more generic ( *args, **kwargs ). Arguments will always be passed as keywords arguments when possible. Replace `@functools.wraps so that it correctly preserves signatures, and enable you to easily access named arguments.","title":"Main features / benefits"},{"location":"#see-also","text":"decorator , which largely inspired this code PEP362 - Function Signature Object A blog entry on dynamic function creation functools.wraps","title":"See Also"},{"location":"#others","text":"Do you like this library ? You might also like my other python libraries","title":"Others"},{"location":"#want-to-contribute","text":"Details on the github page: https://github.com/smarie/python-makefun","title":"Want to contribute ?"},{"location":"api_reference/","text":"API reference \u00b6 In general, using help(symbol) is the recommended way to get the latest documentation. In addition, this page provides an overview of the various elements in this package. Main symbols \u00b6 create_function \u00b6 def create_function ( func_signature : Union [ str , Signature ], func_impl : Callable [[ Any ], Any ], func_name : str = None , inject_as_first_arg : bool = False , add_source : bool = True , add_impl : bool = True , doc : str = None , qualname : str = None , module_name : str = None , ** attrs ): Creates a function with signature func_signature that will call func_impl when called. All arguments received by the generated function will be propagated as keyword-arguments to func_impl when it is possible (so all the time, except for var-positional or positional-only arguments that get passed as *args. Note that positional-only does not yet exist in python but this case is already covered because it is supported by Signature objects). func_signature can be provided in different formats: as a string containing the name and signature without 'def' keyword, such as 'foo(a, b: int, *args, **kwargs)' . In which case the name in the string will be used for the __name__ and __qualname__ of the created function by default. as a Signature object, for example created using signature(f) or handcrafted. Since a Signature object does not contain any name, in this case the __name__ and __qualname__ of the created function will be copied from func_impl by default. All the other metadata of the created function are defined as follows: default __name__ attribute (see above) can be overridden by providing a non-None func_name default __qualname__ attribute (see above) can be overridden by providing a non-None qualname __annotations__ attribute is created to match the annotations in the signature. __doc__ attribute is copied from func_impl.__doc__ except if overridden using doc __module__ attribute is copied from func_impl.__module__ except if overridden using module_name Finally two new attributes are optionally created __source__ attribute: set if add_source is True (default), this attribute contains the source code of the generated function __func_impl__ attribute: set if add_impl is True (default), this attribute contains a pointer to func_impl Parameters: func_signature : either a string without 'def' such as \"foo(a, b: int, args, *kwargs)\" or \"(a, b: int)\", or a Signature object, for example from the output of inspect.signature or from the funcsigs.signature backport. Note that these objects can be created manually too. If the signature is provided as a string and contains a non-empty name, this name will be used instead of the one of the decorated function. func_impl : the function that will be called when the generated function is executed. Its signature should be compliant with (=more generic than) func_signature inject_as_first_arg : if True , the created function will be injected as the first positional argument of func_impl . This can be handy in case the implementation is shared between several facades and needs to know from which context it was called. Default= False func_name : provide a non- None value to override the created function __name__ and __qualname__ . If this is None (default), the __name__ will default to the one of func_impl if func_signature is a Signature , or to the name defined in func_signature if func_signature is a str and contains a non-empty name. add_source : a boolean indicating if a ' source ' annotation should be added to the generated function (default: True) add_impl : a boolean indicating if a ' func_impl ' annotation should be added to the generated function (default: True) doc : a string representing the docstring that will be used to set the doc attribute on the generated function. If None (default), the doc of func_impl will be used. qualname : a string representing the qualified name to be used. If None (default), the __qualname__ will default to the one of func_impl if func_signature is a Signature , or to the name defined in func_signature if func_signature is a str and contains a non-empty name. module_name : the name of the module to be set on the function (under module ). If None (default), func_impl.__module__ will be used. attrs : other keyword attributes that should be set on the function. Note that func_impl.__dict__ is not automatically copied. @with_signature \u00b6 def with_signature ( func_signature : Union [ str , Signature ], func_name : str = None , inject_as_first_arg : bool = False , add_source : bool = True , add_impl : bool = True , doc : str = None , qualname : str = None , module_name : str = None , ** attrs ): A decorator for functions, to change their signature. The new signature should be compliant with the old one. @with_signature ( < arguments > ) def impl ( ... ): ... is totally equivalent to impl = create_function(<arguments>, func_impl=impl) except for one additional behaviour: If func_signature is set to None , there is no TypeError as in create_function. Instead, this simply applies the new metadata (name, doc, module_name, attrs) to the decorated function without creating a wrapper. add_source , add_impl and inject_as_first_arg should not be set in this case. func_signature : the new signature of the decorated function. Either a string without 'def' such as \"foo(a, b: int, args, *kwargs)\" or \"(a, b: int)\", or a Signature object, for example from the output of inspect.signature or from the funcsigs.signature backport. Note that these objects can be created manually too. If the signature is provided as a string and contains a non-empty name, this name will be used instead of the one of the decorated function. Finally None can be provided to indicate that user wants to only change the medatadata (func_name, doc, module_name, attrs) of the decorated function, without generating a new function. inject_as_first_arg : if True , the created function will be injected as the first positional argument of func_impl . This can be handy in case the implementation is shared between several facades and needs to know from which context it was called. Default= False func_name : provide a non- None value to override the created function __name__ and __qualname__ . If this is None (default), the __name__ will default to the one of func_impl if func_signature is a Signature , or to the name defined in func_signature if func_signature is a str and contains a non-empty name. add_source : a boolean indicating if a ' source ' annotation should be added to the generated function (default: True) add_impl : a boolean indicating if a ' func_impl ' annotation should be added to the generated function (default: True) doc : a string representing the docstring that will be used to set the doc attribute on the generated function. If None (default), the doc of the decorated function will be used. qualname : a string representing the qualified name to be used. If None (default), the __qualname__ will default to the one of func_impl if func_signature is a Signature , or to the name defined in func_signature if func_signature is a str and contains a non-empty name. module_name : the name of the module to be set on the function (under module ). If None (default), the __module__ attribute of the decorated function will be used. attrs : other keyword attributes that should be set on the function. Note that the full __dict__ of the decorated function is not automatically copied. @wraps \u00b6 def wraps ( f , new_sig : Union [ str , Signature ] = None , remove_args : Union [ str , Iterable [ str ]] = None , func_name : str = None , inject_as_first_arg : bool = False , add_source : bool = True , add_impl : bool = True , doc : str = None , qualname : str = None , module_name : str = None , ** attrs ): A decorator to create a signature-preserving wrapper function. It is similar to functools.wraps , but relies on a proper dynamically-generated function. Therefore as opposed to functools.wraps , the wrapper body will not be executed if the arguments provided are not compliant with the signature - instead a TypeError will be raised before entering the wrapper body. the arguments will always be received as keywords by the wrapper, when possible. See documentation for details. you can modify the signature of the resulting function, by providing a new one with new_sig . See documentation for details. Note that you can now also easily remove arguments from the signature in order to inject them with your own - with the remove_args parameter, see documentation . Comparison with @with_signature : @wraps(f) is equivalent to `@with_signature(signature(f), func_name=f.__name__, doc=f.__doc__, module_name=f.__module__, qualname=f.__qualname__, __wrapped__=f, **f.__dict__, **attrs)` In other words, as opposed to @with_signature , the metadata (doc, module name, etc.) is provided by the wrapped f , so that the created function seems to be identical (except for the signature if a non-None new_sig is provided). If new_sig is None, we set the additional __wrapped__ attribute on the created function, to stay compliant with the functools.wraps convention. All options in with_signature remain available for overriding. See also python documentation on @wraps create_wrapper \u00b6 def create_wrapper ( wrapped , wrapper , new_sig : Union [ str , Signature ] = None , remove_args : Union [ str , Iterable [ str ]] = None , func_name : str = None , inject_as_first_arg : bool = False , add_source : bool = True , add_impl : bool = True , doc : str = None , qualname : str = None , module_name : str = None , ** attrs ): Creates a signature-preserving wrapper function. create_wrapper(wrapped, wrapper, **kwargs) is equivalent to wraps(wrapped, **kwargs)(wrapper) . @partial \u00b6 def partial ( f : Callable , * preset_pos_args , ** preset_kwargs ): Equivalent of functools.partial but relies on a dynamically-created function. As a result the function looks nicer to users in terms of apparent documentation, name, etc. See documentation for details. @with_partial \u00b6 def with_partial ( * preset_pos_args , ** preset_kwargs ): Decorator to 'partialize' a function using partial . Signature editing utils \u00b6 add_signature_parameters \u00b6 def add_signature_parameters ( s , # type: Signature first = (), # type: Union[Parameter, Iterable[Parameter]] last = (), # type: Union[Parameter, Iterable[Parameter]] custom = (), # type: Union[Parameter, Iterable[Parameter]] custom_idx =- 1 # type: int ): Adds the provided parameters to the signature s (returns a new Signature instance). s : the original signature to edit first : a single element or a list of Parameter instances to be added at the beginning of the parameter's list last : a single element or a list of Parameter instances to be added at the end of the parameter's list custom : a single element or a list of Parameter instances to be added at a custom position in the list. That position is determined with custom_idx custom_idx : the custom position to insert the custom parameters to. remove_signature_parameters \u00b6 def remove_signature_parameters ( s , * param_names ): Removes the provided parameters from the signature s (returns a new Signature instance). Pseudo-compilation \u00b6 compile_fun \u00b6","title":"API reference"},{"location":"api_reference/#api-reference","text":"In general, using help(symbol) is the recommended way to get the latest documentation. In addition, this page provides an overview of the various elements in this package.","title":"API reference"},{"location":"api_reference/#main-symbols","text":"","title":"Main symbols"},{"location":"api_reference/#create_function","text":"def create_function ( func_signature : Union [ str , Signature ], func_impl : Callable [[ Any ], Any ], func_name : str = None , inject_as_first_arg : bool = False , add_source : bool = True , add_impl : bool = True , doc : str = None , qualname : str = None , module_name : str = None , ** attrs ): Creates a function with signature func_signature that will call func_impl when called. All arguments received by the generated function will be propagated as keyword-arguments to func_impl when it is possible (so all the time, except for var-positional or positional-only arguments that get passed as *args. Note that positional-only does not yet exist in python but this case is already covered because it is supported by Signature objects). func_signature can be provided in different formats: as a string containing the name and signature without 'def' keyword, such as 'foo(a, b: int, *args, **kwargs)' . In which case the name in the string will be used for the __name__ and __qualname__ of the created function by default. as a Signature object, for example created using signature(f) or handcrafted. Since a Signature object does not contain any name, in this case the __name__ and __qualname__ of the created function will be copied from func_impl by default. All the other metadata of the created function are defined as follows: default __name__ attribute (see above) can be overridden by providing a non-None func_name default __qualname__ attribute (see above) can be overridden by providing a non-None qualname __annotations__ attribute is created to match the annotations in the signature. __doc__ attribute is copied from func_impl.__doc__ except if overridden using doc __module__ attribute is copied from func_impl.__module__ except if overridden using module_name Finally two new attributes are optionally created __source__ attribute: set if add_source is True (default), this attribute contains the source code of the generated function __func_impl__ attribute: set if add_impl is True (default), this attribute contains a pointer to func_impl Parameters: func_signature : either a string without 'def' such as \"foo(a, b: int, args, *kwargs)\" or \"(a, b: int)\", or a Signature object, for example from the output of inspect.signature or from the funcsigs.signature backport. Note that these objects can be created manually too. If the signature is provided as a string and contains a non-empty name, this name will be used instead of the one of the decorated function. func_impl : the function that will be called when the generated function is executed. Its signature should be compliant with (=more generic than) func_signature inject_as_first_arg : if True , the created function will be injected as the first positional argument of func_impl . This can be handy in case the implementation is shared between several facades and needs to know from which context it was called. Default= False func_name : provide a non- None value to override the created function __name__ and __qualname__ . If this is None (default), the __name__ will default to the one of func_impl if func_signature is a Signature , or to the name defined in func_signature if func_signature is a str and contains a non-empty name. add_source : a boolean indicating if a ' source ' annotation should be added to the generated function (default: True) add_impl : a boolean indicating if a ' func_impl ' annotation should be added to the generated function (default: True) doc : a string representing the docstring that will be used to set the doc attribute on the generated function. If None (default), the doc of func_impl will be used. qualname : a string representing the qualified name to be used. If None (default), the __qualname__ will default to the one of func_impl if func_signature is a Signature , or to the name defined in func_signature if func_signature is a str and contains a non-empty name. module_name : the name of the module to be set on the function (under module ). If None (default), func_impl.__module__ will be used. attrs : other keyword attributes that should be set on the function. Note that func_impl.__dict__ is not automatically copied.","title":"create_function"},{"location":"api_reference/#with_signature","text":"def with_signature ( func_signature : Union [ str , Signature ], func_name : str = None , inject_as_first_arg : bool = False , add_source : bool = True , add_impl : bool = True , doc : str = None , qualname : str = None , module_name : str = None , ** attrs ): A decorator for functions, to change their signature. The new signature should be compliant with the old one. @with_signature ( < arguments > ) def impl ( ... ): ... is totally equivalent to impl = create_function(<arguments>, func_impl=impl) except for one additional behaviour: If func_signature is set to None , there is no TypeError as in create_function. Instead, this simply applies the new metadata (name, doc, module_name, attrs) to the decorated function without creating a wrapper. add_source , add_impl and inject_as_first_arg should not be set in this case. func_signature : the new signature of the decorated function. Either a string without 'def' such as \"foo(a, b: int, args, *kwargs)\" or \"(a, b: int)\", or a Signature object, for example from the output of inspect.signature or from the funcsigs.signature backport. Note that these objects can be created manually too. If the signature is provided as a string and contains a non-empty name, this name will be used instead of the one of the decorated function. Finally None can be provided to indicate that user wants to only change the medatadata (func_name, doc, module_name, attrs) of the decorated function, without generating a new function. inject_as_first_arg : if True , the created function will be injected as the first positional argument of func_impl . This can be handy in case the implementation is shared between several facades and needs to know from which context it was called. Default= False func_name : provide a non- None value to override the created function __name__ and __qualname__ . If this is None (default), the __name__ will default to the one of func_impl if func_signature is a Signature , or to the name defined in func_signature if func_signature is a str and contains a non-empty name. add_source : a boolean indicating if a ' source ' annotation should be added to the generated function (default: True) add_impl : a boolean indicating if a ' func_impl ' annotation should be added to the generated function (default: True) doc : a string representing the docstring that will be used to set the doc attribute on the generated function. If None (default), the doc of the decorated function will be used. qualname : a string representing the qualified name to be used. If None (default), the __qualname__ will default to the one of func_impl if func_signature is a Signature , or to the name defined in func_signature if func_signature is a str and contains a non-empty name. module_name : the name of the module to be set on the function (under module ). If None (default), the __module__ attribute of the decorated function will be used. attrs : other keyword attributes that should be set on the function. Note that the full __dict__ of the decorated function is not automatically copied.","title":"@with_signature"},{"location":"api_reference/#wraps","text":"def wraps ( f , new_sig : Union [ str , Signature ] = None , remove_args : Union [ str , Iterable [ str ]] = None , func_name : str = None , inject_as_first_arg : bool = False , add_source : bool = True , add_impl : bool = True , doc : str = None , qualname : str = None , module_name : str = None , ** attrs ): A decorator to create a signature-preserving wrapper function. It is similar to functools.wraps , but relies on a proper dynamically-generated function. Therefore as opposed to functools.wraps , the wrapper body will not be executed if the arguments provided are not compliant with the signature - instead a TypeError will be raised before entering the wrapper body. the arguments will always be received as keywords by the wrapper, when possible. See documentation for details. you can modify the signature of the resulting function, by providing a new one with new_sig . See documentation for details. Note that you can now also easily remove arguments from the signature in order to inject them with your own - with the remove_args parameter, see documentation . Comparison with @with_signature : @wraps(f) is equivalent to `@with_signature(signature(f), func_name=f.__name__, doc=f.__doc__, module_name=f.__module__, qualname=f.__qualname__, __wrapped__=f, **f.__dict__, **attrs)` In other words, as opposed to @with_signature , the metadata (doc, module name, etc.) is provided by the wrapped f , so that the created function seems to be identical (except for the signature if a non-None new_sig is provided). If new_sig is None, we set the additional __wrapped__ attribute on the created function, to stay compliant with the functools.wraps convention. All options in with_signature remain available for overriding. See also python documentation on @wraps","title":"@wraps"},{"location":"api_reference/#create_wrapper","text":"def create_wrapper ( wrapped , wrapper , new_sig : Union [ str , Signature ] = None , remove_args : Union [ str , Iterable [ str ]] = None , func_name : str = None , inject_as_first_arg : bool = False , add_source : bool = True , add_impl : bool = True , doc : str = None , qualname : str = None , module_name : str = None , ** attrs ): Creates a signature-preserving wrapper function. create_wrapper(wrapped, wrapper, **kwargs) is equivalent to wraps(wrapped, **kwargs)(wrapper) .","title":"create_wrapper"},{"location":"api_reference/#partial","text":"def partial ( f : Callable , * preset_pos_args , ** preset_kwargs ): Equivalent of functools.partial but relies on a dynamically-created function. As a result the function looks nicer to users in terms of apparent documentation, name, etc. See documentation for details.","title":"@partial"},{"location":"api_reference/#with_partial","text":"def with_partial ( * preset_pos_args , ** preset_kwargs ): Decorator to 'partialize' a function using partial .","title":"@with_partial"},{"location":"api_reference/#signature-editing-utils","text":"","title":"Signature editing utils"},{"location":"api_reference/#add_signature_parameters","text":"def add_signature_parameters ( s , # type: Signature first = (), # type: Union[Parameter, Iterable[Parameter]] last = (), # type: Union[Parameter, Iterable[Parameter]] custom = (), # type: Union[Parameter, Iterable[Parameter]] custom_idx =- 1 # type: int ): Adds the provided parameters to the signature s (returns a new Signature instance). s : the original signature to edit first : a single element or a list of Parameter instances to be added at the beginning of the parameter's list last : a single element or a list of Parameter instances to be added at the end of the parameter's list custom : a single element or a list of Parameter instances to be added at a custom position in the list. That position is determined with custom_idx custom_idx : the custom position to insert the custom parameters to.","title":"add_signature_parameters"},{"location":"api_reference/#remove_signature_parameters","text":"def remove_signature_parameters ( s , * param_names ): Removes the provided parameters from the signature s (returns a new Signature instance).","title":"remove_signature_parameters"},{"location":"api_reference/#pseudo-compilation","text":"","title":"Pseudo-compilation"},{"location":"api_reference/#compile_fun","text":"","title":"compile_fun"},{"location":"changelog/","text":"Changelog \u00b6 1.10.1 - Github actions migration \u00b6 Technical release: validation of the new github actions workflow for PyPi deployment. 1.10.0 - Removing arguments easily in @wraps \u00b6 @wraps now offers a remove_params argument allowing one to remove an argument from the exposed signature, typically to create and inject it in the wrapper. Fixes #60 1.9.5 - Bugfix with partial when f has no args \u00b6 partial can now be used to create a copy of a function with no args. Fixed ValueError: Cannot preset 0 positional args, function case_second has only 0 args. . Fixed #59 1.9.4 - removed six dependency \u00b6 Removed unused six dependency. Note: this version will ship in conda forge. 1.9.3 - Minor compatibility fixes with functools.partial \u00b6 @wraps can now be used to wrap a functools.partial . Fixed #57 create_function now correctly reuses information from the partialized function if a functools.partial is used as the implementation. create_function now raises a more explicit error when no func_name can be found. makefun.partial now generates a signature that is more consistent with functools.partial . Fixes #58 1.9.2 - packaging improvements \u00b6 packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the setup.py . In particular removed dependency to six for setup and added py.typed file, as well as set the zip_safe flag to False. Removed tests folder from package. Fixes #54 1.9.1 - @compile_fun bugfix \u00b6 Fixed OSError: could not get source code or IOError: could not get source code when @compile_fun is used on a function that depends on an already-compiled function. Fixed #51 1.9.0 - @compile_fun improvements, bugfix and better exception \u00b6 @compile_fun : added capability to disable recursive compilation ( recurse arg) , and to exclude some names from compilation ( except_names arg). Fixed #49 and #50 Fixed issue ValueError: Cell is empty with @compile_fun . Fixed #48 Now raising an UndefinedSymbolError when a symbol is not known at compilation time. One step towards #47 1.8.0 - new @compile_fun goodie \u00b6 New goodie @compile_fun decorator to compile a function so that it can not be navigated to using the debugger. Fixes #46 1.7.0 - minor goodies update \u00b6 add_signature_parameters now accepts that one specifies a custom index where to insert the new parameters. 1.6.11 - Added version attribute \u00b6 Added __version__ attribute to comply with PEP396, following this guide . Fixes #45 . 1.6.10 - Fixed dependencies 2 \u00b6 Fixed six dependency: also declared as a setup dependency. 1.6.9 - Fixed dependencies \u00b6 Added missing six dependency explicitly. 1.6.8 - Improved performance \u00b6 Improved performance of inner method get_signature_string (used by all entry points) after profiling. 1.6.7 - Increased tolerance to function signatures in python 2 \u00b6 In python 2 some libraries such as attrs can modify the annotations manually, making signature return a string representation that is not compliant with the language version. This raised a SyntaxError in previous versions. The new version silently removes all these annotations in python versions that do not support them. Fixes #39 . 1.6.6 - Bug fix \u00b6 Fixed yet another nasty varpositional-related bug :). Fixes #38 . 1.6.5 - Bug fix \u00b6 Fixed NameError in case of unknown symbols in type hints. Fixes #37 . 1.6.4 - Bug fix and minor improvement \u00b6 Fixed PEP8 error in source code. Fixes #35 . Now string signatures can contain a colon. Fixes #36 1.6.3 - Bug fix with type hints in signature \u00b6 Fixed bug when the return type annotation of the function to create contains non-locally available type hints. Fixes #33 . 1.6.2 - Bug fix with type hints in signature \u00b6 Fixed bug when the signature of the function to create contains non-locally available type hints. Fixes #32 . 1.6.1 - with_partial and partial minor bug fix \u00b6 Fixed partial to support missing and empty docstring. Fixes #31 . 1.6.0 - added with_partial and partial \u00b6 New method partial that behaves like functools.partial , and equivalent decorator @with_partial . Fixes #30 . 1.5.1 - bug fix \u00b6 add_signature_parameters now correctly inserts parameters in the right order when they are prepended (using first= ). Fixed #29 . 1.5.0 - Major refactoring and bugfixes \u00b6 Function creation API: renamed all handler into impl for clarity. Fixes #27 . renamed addsource and addhandler arguments as add_source and add_impl respectively, for consistency signatures can not be provided as a callable anymore - that was far too confusing. If the reference signature is a callable, then use @wraps or create_wrapper , because that's probably what you want to do (= reuse not only the signature but also all metadata). Fixes #26 . the function name is now optional in signatures provided as string. now setting __qualname__ attribute default function name, qualname, doc and module name are the ones from func_impl in create_function and @with_signature , and are the ones from the wrapped function in create_wrapper and @wraps as intuitively expected. Fixes #28 . Wrappers: @wraps and create_wrapper now offer a new_sig argument. In that case the __wrapped__ attribute is not set. Fixes #25 . @wraps and create_wrapper now correctly preserve the __dict__ and other metadata from the wrapped item. Fixes #24 1.4.0 - Non-representable default values are now handled correctly \u00b6 When a non-representable default value was used in the signature to generate, the code failed with a SyntaxError . This case is now correctly handled, by storing the corresponding variable in the generated function's context. Fixes #23 . 1.3.0 - Aliases for signature-preserving wrapper scenarios \u00b6 Now providing a @wraps , equivalent of functools.wraps ; and a create_wrapper equivalent of functools.update_wrapper . Fixes #21 @with_signature now does not override the __name__ when signature is provided as a function. Fixes #22 add_signature_parameters now accepts that parameters are provided as single elements (not necessarily iterables) Updated documentation 1.2.0 - @with_signature supports None \u00b6 None can be used as the desired signature of @with_signature . This indicated that the user does not want to create a new function but only wants to update the metadata. Fixes #20 . 1.1.2 - Fixes \u00b6 Fixed isgeneratorfunction for old python versions, see decorator#63 . Python<3.3-specific function body is now not loaded at all if not needed. 1.1.1 - @with_signature fix \u00b6 inject_as_first_arg was missing from @with_signature , added it. Fixed #18 . 1.1.0 - Support for generators and coroutines \u00b6 Now create_function and @with_signature create the same kind of function than the handler. So if it is a generator, a generator-based coroutine, or an async coroutine, the generated function will adapt. Fixes #6 . 1.0.2 - Fixed @with_signature \u00b6 Now a string signature can be provided to @with_signature without problem. Fixed #17 . 1.0.1 - minor: fixed PyPi doc \u00b6 1.0.0 - New parameters, new goodie, and bugfix \u00b6 @with_signature : now exposes all options of create_function . Fixed #12 . now correctly sets the module name by default. Fixes #13 now accepts None as the new func_signature to declare that the signature is identical to the decorated function. This can be handy to just change the docstring or module name of a function for example. Fixes #15 create_function and @with_signature : New module_name parameter to override the module name. Fixes #14 the handler is now available as a field of the generated function (under __func_impl__ ). New addhandler parameter (default: True) controls this behaviour. Fixes #16 Misc: New goodie to manipulate signatures: add_signature_parameters . Fixed dependencies for documentation auto-build. 0.5.0 - New helper function, and bugfix \u00b6 New helper function remove_signature_parameters . Fixed issue with @with_signature when argument is a Signature . Fixes #11 0.4.0 - New @with_signature decorator, and create_function accepts functions \u00b6 New decorator @with_signature to change the signature of a callable. Fixes #3 create_function now accepts that a function be passed as a signature template. Fixes #10 0.3.0 - Ability to generate functions from Signature \u00b6 Functions can now be created from a Signature object, in addition to string signatures. This unlocks many useful use cases, among easily creating function wrappers. Note: the inner function that provides this feature is get_signature_from_string . Fixes #8 Improved design by getting rid of the regular expression parser to check parameters definition. This assumes that the compiler will correctly raise exceptions when a string signature is not correct, and that inspect.signature or funcsigs.signature works correctly at detecting all the parameter kinds and annotations on the resulting function. It seems like a fair assumption... Fixes #9 . 0.2.0 - Various new features and improvements \u00b6 create_function : create_function does not require users to prepend \"def \" to the signature anymore. Fixed #5 Return annotations are now supported. Fixes #4 . Type hint as comments are supported but the generated function loses the annotations because inspect.signature loses the annotation too in that case. Fixes #7 Variable-length arguments such as *args and **kwargs are now properly handled. Fixes #2 Handler functions can now receive the dynamically created function as first argument, by using create_function(func_signature, func_handler, inject_as_first_arg=True) . Fixes #1 Renamed _call_ into _func_impl_ in the generated code. Misc: Added pytest-cases dependency for tests. 0.1.0 - First public version \u00b6 First version created, largely inspired by decorator","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#1101-github-actions-migration","text":"Technical release: validation of the new github actions workflow for PyPi deployment.","title":"1.10.1 - Github actions migration"},{"location":"changelog/#1100-removing-arguments-easily-in-wraps","text":"@wraps now offers a remove_params argument allowing one to remove an argument from the exposed signature, typically to create and inject it in the wrapper. Fixes #60","title":"1.10.0 - Removing arguments easily in @wraps"},{"location":"changelog/#195-bugfix-with-partial-when-f-has-no-args","text":"partial can now be used to create a copy of a function with no args. Fixed ValueError: Cannot preset 0 positional args, function case_second has only 0 args. . Fixed #59","title":"1.9.5 - Bugfix with partial when f has no args"},{"location":"changelog/#194-removed-six-dependency","text":"Removed unused six dependency. Note: this version will ship in conda forge.","title":"1.9.4 - removed six dependency"},{"location":"changelog/#193-minor-compatibility-fixes-with-functoolspartial","text":"@wraps can now be used to wrap a functools.partial . Fixed #57 create_function now correctly reuses information from the partialized function if a functools.partial is used as the implementation. create_function now raises a more explicit error when no func_name can be found. makefun.partial now generates a signature that is more consistent with functools.partial . Fixes #58","title":"1.9.3 - Minor compatibility fixes with functools.partial"},{"location":"changelog/#192-packaging-improvements","text":"packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the setup.py . In particular removed dependency to six for setup and added py.typed file, as well as set the zip_safe flag to False. Removed tests folder from package. Fixes #54","title":"1.9.2 - packaging improvements"},{"location":"changelog/#191-compile_fun-bugfix","text":"Fixed OSError: could not get source code or IOError: could not get source code when @compile_fun is used on a function that depends on an already-compiled function. Fixed #51","title":"1.9.1 - @compile_fun bugfix"},{"location":"changelog/#190-compile_fun-improvements-bugfix-and-better-exception","text":"@compile_fun : added capability to disable recursive compilation ( recurse arg) , and to exclude some names from compilation ( except_names arg). Fixed #49 and #50 Fixed issue ValueError: Cell is empty with @compile_fun . Fixed #48 Now raising an UndefinedSymbolError when a symbol is not known at compilation time. One step towards #47","title":"1.9.0 - @compile_fun improvements, bugfix and better exception"},{"location":"changelog/#180-new-compile_fun-goodie","text":"New goodie @compile_fun decorator to compile a function so that it can not be navigated to using the debugger. Fixes #46","title":"1.8.0 - new @compile_fun goodie"},{"location":"changelog/#170-minor-goodies-update","text":"add_signature_parameters now accepts that one specifies a custom index where to insert the new parameters.","title":"1.7.0 - minor goodies update"},{"location":"changelog/#1611-added-version-attribute","text":"Added __version__ attribute to comply with PEP396, following this guide . Fixes #45 .","title":"1.6.11 - Added version attribute"},{"location":"changelog/#1610-fixed-dependencies-2","text":"Fixed six dependency: also declared as a setup dependency.","title":"1.6.10 - Fixed dependencies 2"},{"location":"changelog/#169-fixed-dependencies","text":"Added missing six dependency explicitly.","title":"1.6.9 - Fixed dependencies"},{"location":"changelog/#168-improved-performance","text":"Improved performance of inner method get_signature_string (used by all entry points) after profiling.","title":"1.6.8 - Improved performance"},{"location":"changelog/#167-increased-tolerance-to-function-signatures-in-python-2","text":"In python 2 some libraries such as attrs can modify the annotations manually, making signature return a string representation that is not compliant with the language version. This raised a SyntaxError in previous versions. The new version silently removes all these annotations in python versions that do not support them. Fixes #39 .","title":"1.6.7 - Increased tolerance to function signatures in python 2"},{"location":"changelog/#166-bug-fix","text":"Fixed yet another nasty varpositional-related bug :). Fixes #38 .","title":"1.6.6 - Bug fix"},{"location":"changelog/#165-bug-fix","text":"Fixed NameError in case of unknown symbols in type hints. Fixes #37 .","title":"1.6.5 - Bug fix"},{"location":"changelog/#164-bug-fix-and-minor-improvement","text":"Fixed PEP8 error in source code. Fixes #35 . Now string signatures can contain a colon. Fixes #36","title":"1.6.4 - Bug fix and minor improvement"},{"location":"changelog/#163-bug-fix-with-type-hints-in-signature","text":"Fixed bug when the return type annotation of the function to create contains non-locally available type hints. Fixes #33 .","title":"1.6.3 - Bug fix with type hints in signature"},{"location":"changelog/#162-bug-fix-with-type-hints-in-signature","text":"Fixed bug when the signature of the function to create contains non-locally available type hints. Fixes #32 .","title":"1.6.2 - Bug fix with type hints in signature"},{"location":"changelog/#161-with_partial-and-partial-minor-bug-fix","text":"Fixed partial to support missing and empty docstring. Fixes #31 .","title":"1.6.1 - with_partial and partial minor bug fix"},{"location":"changelog/#160-added-with_partial-and-partial","text":"New method partial that behaves like functools.partial , and equivalent decorator @with_partial . Fixes #30 .","title":"1.6.0 - added with_partial and partial"},{"location":"changelog/#151-bug-fix","text":"add_signature_parameters now correctly inserts parameters in the right order when they are prepended (using first= ). Fixed #29 .","title":"1.5.1 - bug fix"},{"location":"changelog/#150-major-refactoring-and-bugfixes","text":"Function creation API: renamed all handler into impl for clarity. Fixes #27 . renamed addsource and addhandler arguments as add_source and add_impl respectively, for consistency signatures can not be provided as a callable anymore - that was far too confusing. If the reference signature is a callable, then use @wraps or create_wrapper , because that's probably what you want to do (= reuse not only the signature but also all metadata). Fixes #26 . the function name is now optional in signatures provided as string. now setting __qualname__ attribute default function name, qualname, doc and module name are the ones from func_impl in create_function and @with_signature , and are the ones from the wrapped function in create_wrapper and @wraps as intuitively expected. Fixes #28 . Wrappers: @wraps and create_wrapper now offer a new_sig argument. In that case the __wrapped__ attribute is not set. Fixes #25 . @wraps and create_wrapper now correctly preserve the __dict__ and other metadata from the wrapped item. Fixes #24","title":"1.5.0 - Major refactoring and bugfixes"},{"location":"changelog/#140-non-representable-default-values-are-now-handled-correctly","text":"When a non-representable default value was used in the signature to generate, the code failed with a SyntaxError . This case is now correctly handled, by storing the corresponding variable in the generated function's context. Fixes #23 .","title":"1.4.0 - Non-representable default values are now handled correctly"},{"location":"changelog/#130-aliases-for-signature-preserving-wrapper-scenarios","text":"Now providing a @wraps , equivalent of functools.wraps ; and a create_wrapper equivalent of functools.update_wrapper . Fixes #21 @with_signature now does not override the __name__ when signature is provided as a function. Fixes #22 add_signature_parameters now accepts that parameters are provided as single elements (not necessarily iterables) Updated documentation","title":"1.3.0 - Aliases for signature-preserving wrapper scenarios"},{"location":"changelog/#120-with_signature-supports-none","text":"None can be used as the desired signature of @with_signature . This indicated that the user does not want to create a new function but only wants to update the metadata. Fixes #20 .","title":"1.2.0 - @with_signature supports None"},{"location":"changelog/#112-fixes","text":"Fixed isgeneratorfunction for old python versions, see decorator#63 . Python<3.3-specific function body is now not loaded at all if not needed.","title":"1.1.2 - Fixes"},{"location":"changelog/#111-with_signature-fix","text":"inject_as_first_arg was missing from @with_signature , added it. Fixed #18 .","title":"1.1.1 - @with_signature fix"},{"location":"changelog/#110-support-for-generators-and-coroutines","text":"Now create_function and @with_signature create the same kind of function than the handler. So if it is a generator, a generator-based coroutine, or an async coroutine, the generated function will adapt. Fixes #6 .","title":"1.1.0 - Support for generators and coroutines"},{"location":"changelog/#102-fixed-with_signature","text":"Now a string signature can be provided to @with_signature without problem. Fixed #17 .","title":"1.0.2 - Fixed @with_signature"},{"location":"changelog/#101-minor-fixed-pypi-doc","text":"","title":"1.0.1 - minor: fixed PyPi doc"},{"location":"changelog/#100-new-parameters-new-goodie-and-bugfix","text":"@with_signature : now exposes all options of create_function . Fixed #12 . now correctly sets the module name by default. Fixes #13 now accepts None as the new func_signature to declare that the signature is identical to the decorated function. This can be handy to just change the docstring or module name of a function for example. Fixes #15 create_function and @with_signature : New module_name parameter to override the module name. Fixes #14 the handler is now available as a field of the generated function (under __func_impl__ ). New addhandler parameter (default: True) controls this behaviour. Fixes #16 Misc: New goodie to manipulate signatures: add_signature_parameters . Fixed dependencies for documentation auto-build.","title":"1.0.0 - New parameters, new goodie, and bugfix"},{"location":"changelog/#050-new-helper-function-and-bugfix","text":"New helper function remove_signature_parameters . Fixed issue with @with_signature when argument is a Signature . Fixes #11","title":"0.5.0 - New helper function, and bugfix"},{"location":"changelog/#040-new-with_signature-decorator-and-create_function-accepts-functions","text":"New decorator @with_signature to change the signature of a callable. Fixes #3 create_function now accepts that a function be passed as a signature template. Fixes #10","title":"0.4.0 - New @with_signature decorator, and create_function accepts functions"},{"location":"changelog/#030-ability-to-generate-functions-from-signature","text":"Functions can now be created from a Signature object, in addition to string signatures. This unlocks many useful use cases, among easily creating function wrappers. Note: the inner function that provides this feature is get_signature_from_string . Fixes #8 Improved design by getting rid of the regular expression parser to check parameters definition. This assumes that the compiler will correctly raise exceptions when a string signature is not correct, and that inspect.signature or funcsigs.signature works correctly at detecting all the parameter kinds and annotations on the resulting function. It seems like a fair assumption... Fixes #9 .","title":"0.3.0 - Ability to generate functions from Signature"},{"location":"changelog/#020-various-new-features-and-improvements","text":"create_function : create_function does not require users to prepend \"def \" to the signature anymore. Fixed #5 Return annotations are now supported. Fixes #4 . Type hint as comments are supported but the generated function loses the annotations because inspect.signature loses the annotation too in that case. Fixes #7 Variable-length arguments such as *args and **kwargs are now properly handled. Fixes #2 Handler functions can now receive the dynamically created function as first argument, by using create_function(func_signature, func_handler, inject_as_first_arg=True) . Fixes #1 Renamed _call_ into _func_impl_ in the generated code. Misc: Added pytest-cases dependency for tests.","title":"0.2.0 - Various new features and improvements"},{"location":"changelog/#010-first-public-version","text":"First version created, largely inspired by decorator","title":"0.1.0 - First public version"},{"location":"long_description/","text":"makefun \u00b6 Small library to dynamically create python functions. The documentation for users is available here: https://smarie.github.io/python-makefun/ A readme for developers is available here: https://github.com/smarie/python-makefun","title":"makefun"},{"location":"long_description/#makefun","text":"Small library to dynamically create python functions. The documentation for users is available here: https://smarie.github.io/python-makefun/ A readme for developers is available here: https://github.com/smarie/python-makefun","title":"makefun"}]}