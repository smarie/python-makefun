{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"makefun","text":"<p>Dynamically create python functions with a proper signature.</p> <p> </p> <p> </p> <p>New <code>prepend_args</code>, <code>append_args</code>, and <code>remove_args</code> parameters in <code>@wraps</code>. See below for details !</p> <p><code>makefun</code> helps you create functions dynamically, with the signature of your choice. It was largely inspired by <code>decorator</code> and <code>functools</code>, and created mainly to cover some of their limitations.</p> <p>The typical use cases are:</p> <ul> <li> <p>creating signature-preserving function wrappers - just like <code>functools.wraps</code> but with accurate <code>TypeError</code> exception raising when user-provided arguments are wrong, and with a very convenient way to access argument values.</p> </li> <li> <p>creating function wrappers that have more or less arguments that the function they wrap. A bit like <code>functools.partial</code> but a lot more flexible and friendly for your users. For example, I use it in my pytest plugins to add a <code>requests</code> parameter to users' tests or fixtures when they do not already have it.</p> </li> <li> <p>more generally, creating functions with a signature derived from a reference signature,</p> </li> <li> <p>or even creating functions with a signature completely defined at runtime.</p> </li> </ul> <p>It currently supports three ways to define the signature of the created function</p> <ul> <li>from a given reference function, e.g. <code>foo</code>.</li> <li>from strings, e.g. <code>'foo(a, b=1)'</code></li> <li>from <code>Signature</code> objects, either manually created, or obtained by using the <code>inspect.signature</code> (or its backport <code>funcsigs.signature</code>) method.</li> </ul> <p>creating signature-preserving decorators</p> <p>Creating decorators and creating signature-preserving function wrappers are two independent problems. <code>makefun</code> is solely focused on the second problem. If you wish to solve the first problem you can look at <code>decopatch</code>. It provides a compact syntax, relying on <code>makefun</code>, if you wish to tackle both at once.</p>"},{"location":"#installing","title":"Installing","text":"<pre><code>&gt; pip install makefun\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#1-ex-nihilo-creation","title":"1- Ex-nihilo creation","text":"<p>Let's create a function <code>foo(b, a=0)</code> implemented by <code>func_impl</code>. The easiest way to provide the signature is as a <code>str</code>:</p> <pre><code>from makefun import create_function\n\n# (1) define the signature. Warning: do not put 'def' keyword here!\nfunc_sig = \"foo(b, a=0)\"\n\n# (2) define the function implementation\ndef func_impl(*args, **kwargs):\n    \"\"\"This docstring will be used in the generated function by default\"\"\"\n    print(\"func_impl called !\")\n    return args, kwargs\n\n# (3) create the dynamic function\ngen_func = create_function(func_sig, func_impl)\n</code></pre> <p>We can test it:</p> <pre><code>&gt;&gt;&gt; args, kwargs = gen_func(2)\nfunc_impl called !\n&gt;&gt;&gt; assert args == ()\n&gt;&gt;&gt; assert kwargs == {'a': 0, 'b': 2}\n</code></pre> <p>You can also:</p> <ul> <li>remove the name from the signature string (e.g. <code>'(b, a=0)'</code>) to directly use the function name of <code>func_impl</code>.</li> <li>override the function name, docstring, qualname and module name if you pass a non-None <code>func_name</code>, <code>doc</code>, <code>qualname</code> and <code>module_name</code> argument</li> <li>add other attributes on the generated function if you pass additional keyword arguments</li> </ul> <p>See API reference for details.</p>"},{"location":"#arguments-mapping","title":"Arguments mapping","text":"<p>We can see above that <code>args</code> is empty, even if we called <code>gen_func</code> with a positional argument. This is completely normal: this is because the created function does not expose <code>(*args, **kwargs)</code> but exposes the desired signature <code>(b, a=0)</code>. So as for usual python function calls, we lose the information about what was provided as positional and what was provided as keyword. You can try it yourself: write a function <code>def foo(b, a=0)</code> and now try to guess from the function body what was provided as positional, and what was provided as keyword...</p> <p>This behaviour is actually a great feature because it makes it much easier to develop the <code>func_impl</code>! Indeed, except if your desired signature contains positional-only (not yet available as of python 3.7) or var-positional (e.g. <code>*args</code>) arguments, you will always find all named arguments in <code>**kwargs</code>.</p>"},{"location":"#more-compact-syntax","title":"More compact syntax","text":"<p>You can use the <code>@with_signature</code> decorator to perform exactly the same things than <code>create_function</code>, but in a more compact way:</p> <pre><code>from makefun import with_signature\n\n@with_signature(\"foo(b, a=0)\")\ndef gen_func(*args, **kwargs):\n    \"\"\"This docstring will be used in the generated function by default\"\"\"\n    print(\"func_impl called !\")\n    return args, kwargs\n</code></pre> <p>It also has the capability to take <code>None</code> as a signature, if you just want to update the metadata (<code>func_name</code>, <code>doc</code>, <code>qualname</code>, <code>module_name</code>) without creating any function:</p> <pre><code>@with_signature(None, func_name='f')\ndef foo(a):\n    return a\n\nassert foo.__name__ == 'f'\n</code></pre> <p>See API reference for details.</p>"},{"location":"#pep484-type-hints-in-str","title":"PEP484 type hints in <code>str</code>","text":"<p>PEP484 type hints are supported in string function definitions:</p> <pre><code>func_sig = \"foo(b: int, a: float = 0) -&gt; str\"\n</code></pre> <p>PEP484 type comments are also supported:</p> <pre><code>func_signature = \"\"\"\nfoo(b,      # type: int\n    a = 0,  # type: float\n    ):\n    # type: (...) -&gt; str\n\"\"\"\n</code></pre> <p>but unfortunately <code>inspect.signature</code> is not able to detect them so the generated function does not contain the annotations. See this example. </p>"},{"location":"#using-signature-objects","title":"Using <code>Signature</code> objects","text":"<p><code>create_function</code> and <code>@with_signature</code> are able to accept a <code>Signature</code> object as input, instead of a <code>str</code>. That might be more convenient than using strings to programmatically define signatures. For example we can rewrite the above script using <code>Signature</code>:</p> <pre><code>from makefun import with_signature\nfrom inspect import Signature, Parameter\n\n# (1) define the signature using objects.\nparameters = [Parameter('b', kind=Parameter.POSITIONAL_OR_KEYWORD),\n              Parameter('a', kind=Parameter.POSITIONAL_OR_KEYWORD, default=0), ]\nfunc_sig = Signature(parameters)\nfunc_name = 'foo'\n\n# (2) define the function\n@with_signature(func_sig, func_name=func_name)\ndef gen_func(*args, **kwargs):\n    \"\"\"This docstring will be used in the generated function by default\"\"\"\n    print(\"func_impl called !\")\n    return args, kwargs\n</code></pre> <p>Note that <code>Signature</code> objects do not contain any function name information. You therefore have to provide an explicit <code>func_name</code> argument to <code>@with_signature</code> (or to <code>create_function</code>) as shown above.</p> <p><code>Signature</code> availability in python 2</p> <p>In python 2 the <code>inspect</code> package does not provide any signature-related features, but a complete backport is available: <code>funcsigs</code>.</p>"},{"location":"#2-deriving-from-existing-signatures","title":"2- Deriving from existing signatures","text":"<p>In many real-world applications we want to reuse \"as is\", or slightly modify, an existing signature.</p>"},{"location":"#copying-a-signature","title":"Copying a signature","text":"<p>If you just want to expose the same signature as a reference function (and not wrap it nor appear like it), the easiest way to copy the signature from another function <code>f</code> is to use <code>signature(f)</code> from <code>inspect</code>/<code>funcsigs</code>.</p>"},{"location":"#signature-preserving-function-wrappers","title":"Signature-preserving function wrappers","text":"<p><code>@functools.wraps</code> is a famous decorator to create \"signature-preserving\" function wrappers. However it does not actually preserve the signature, it just uses a trick (setting the <code>__wrapped__</code> attribute) to trigger special dedicated behaviour in <code>stdlib</code>'s <code>help()</code> and <code>signature()</code> methods. See here.</p> <p>This has two major limitations: </p> <ol> <li>the wrapper code will execute even when the provided arguments are invalid. </li> <li>the wrapper code can not easily access an argument using its name, from the received <code>*args, **kwargs</code>. Indeed one would have to handle all cases (positional, keyword, default) and therefore to use something like <code>Signature.bind()</code>.</li> </ol> <p><code>makefun</code> provides a convenient replacement for <code>@wraps</code> that fixes these two issues:</p> <pre><code>from makefun import wraps\n\n# a dummy function\ndef foo(a, b=1):\n    \"\"\" foo doc \"\"\"\n    return a + b\n\n# our signature-preserving wrapper\n@wraps(foo)\ndef enhanced_foo(*args, **kwargs):\n    print('hello!')\n    print('b=%s' % kwargs['b'])  # we can reliably access 'b'\n    return foo(*args, **kwargs)\n</code></pre> <p>We can check that the wrapper behaves correctly whatever the call modes:</p> <pre><code>&gt;&gt;&gt; assert enhanced_foo(1, 2) == 3  # positional 'b'\nhello!\nb=2\n&gt;&gt;&gt; assert enhanced_foo(b=0, a=1) == 1  # keyword 'b'\nhello!\nb=0\n&gt;&gt;&gt; assert enhanced_foo(1) == 2  # default 'b'\nhello!\nb=1\n</code></pre> <p>And let's pass wrong arguments to it: we see that the wrapper is not executed.</p> <pre><code>&gt;&gt;&gt; enhanced_foo()\nTypeError: foo() missing 1 required positional argument: 'a'\n</code></pre> <p>You can try to do the same experiment with <code>functools.wraps</code> to see the difference.</p> <p>Finally note that a <code>create_wrapper</code> function is also provided for convenience ; it is the equivalent of <code>@wraps</code> but as a standard function - not a decorator.</p> <p>creating signature-preserving decorators</p> <p>Creating decorators and creating signature-preserving function wrappers are two independent problems. <code>makefun</code> is solely focused on the second problem. If you wish to solve the first problem you can look at <code>decopatch</code>. It provides a compact syntax, relying on <code>makefun</code>, if you wish to tackle both at once.</p>"},{"location":"#editing-a-signature","title":"Editing a signature","text":"<p>Below we show how to add a parameter to a function. We first capture its <code>Signature</code> using <code>inspect.signature(f)</code>, we modify it to add a parameter, and finally we use it in <code>wraps</code> to create our final function:</p> <pre><code>from makefun import wraps\nfrom inspect import signature, Parameter\n\n# (0) the reference function\ndef foo(b, a=0):\n    print(\"foo called: b=%s, a=%s\" % (b, a))\n    return b, a\n\n# (1a) capture the signature of reference function `foo`\nfoo_sig = signature(foo)\nprint(\"Original Signature: %s\" % foo_sig)\n\n# (1b) modify the signature to add a new parameter 'z' as first argument\nparams = list(foo_sig.parameters.values())\nparams.insert(0, Parameter('z', kind=Parameter.POSITIONAL_OR_KEYWORD))\nnew_sig = foo_sig.replace(parameters=params)\nprint(\"New Signature: %s\" % new_sig)\n\n# (2) define the wrapper implementation\n@wraps(foo, new_sig=new_sig)\ndef foo_wrapper(z, *args, **kwargs):\n    print(\"foo_wrapper called ! z=%s\" % z)\n    # call the foo function \n    output = foo(*args, **kwargs)\n    # return augmented output\n    return z, output\n\n# call it\nassert foo_wrapper(3, 2) == (3, (2, 0))\n</code></pre> <p>yields</p> <pre><code>Original Signature: (b, a=0)\nNew Signature: (z, b, a=0)\n\nfoo_wrapper called ! z=3\nfoo called: b=2, a=0\n</code></pre> <p>This way you can therefore easily create function wrappers with different signatures: not only adding, but also removing parameters, changing their kind (forcing keyword-only for example), etc. The possibilities are as endless as the capabilities of the <code>Signature</code> objects.</p> <p>Two helper functions are provided in this toolbox to make it a bit easier for you to edit <code>Signature</code> objects:</p> <ul> <li><code>remove_signature_parameters</code> creates a new signature from an existing one by removing all parameters corresponding to the names provided</li> <li><code>add_signature_parameters</code> prepends the <code>Parameter</code>s provided in its <code>first=</code> argument, and appends the ones provided in its <code>last</code> argument.</li> </ul> <pre><code>from makefun import add_signature_parameters, remove_signature_parameters\n\ndef foo(b, c, a=0):\n    pass\n\n# original signature\nfoo_sig = signature(foo)\nprint(\"original signature: %s\" % foo_sig)\n\n# let's modify it\nnew_sig = add_signature_parameters(foo_sig,\n                first=Parameter('z', kind=Parameter.POSITIONAL_OR_KEYWORD),\n                last=Parameter('o', kind=Parameter.POSITIONAL_OR_KEYWORD, \n                               default=True)\n          )\nnew_sig = remove_signature_parameters(new_sig, 'b', 'a')\nprint(\"modified signature: %s\" % new_sig)\n</code></pre> <p>yields</p> <pre><code>original signature: (b, c, a=0)\nmodified signature: (z, c, o=True)\n</code></pre> <p>They might save you a few lines of code if your use-case is not too specific.</p>"},{"location":"#easier-edits","title":"Easier edits","text":"<p>Now <code>@wraps</code> supports three new parameters to easily add or remove parameters to a signature: <code>append_args</code>, <code>prepend_args</code>, and <code>remove_args</code>. The above example can therefore be simplified to</p> <pre><code>from makefun import wraps\n\ndef foo(b, a=0):\n    print(\"foo called: b=%s, a=%s\" % (b, a))\n    return b, a\n\n@wraps(foo, prepend_args='z')\ndef foo_wrapper(z, *args, **kwargs):\n    print(\"foo_wrapper called ! z=%s\" % z)\n    # call the foo function \n    output = foo(*args, **kwargs)\n    # return augmented output\n    return z, output\n\n# call it\nassert foo_wrapper(3, 2) == (3, (2, 0))\n</code></pre> <p>See api documentation for details.</p>"},{"location":"#removing-parameters-easily","title":"Removing parameters easily","text":""},{"location":"#to-replace-them-with-a-hardcoded-value","title":"To replace them with a hardcoded value","text":"<p>As goodies, <code>makefun</code> provides a <code>partial</code> function that are equivalent to <code>functools.partial</code>, except that it is fully signature-preserving and modifies the documentation with a nice helper message explaining that this is a partial view:</p> <pre><code>def foo(x, y):\n    \"\"\"\n    a `foo` function\n\n    :param x:\n    :param y:\n    :return:\n    \"\"\"\n    return x + y\n\nfrom makefun import partial\nbar = partial(foo, x=12)\n</code></pre> <p>we can test it:</p> <pre><code>&gt;&gt;&gt; assert bar(1) == 13\n&gt;&gt;&gt; help(bar)\nHelp on function bar in module makefun.tests.test_partial_and_macros:\n\nbar(y)\n    &lt;This function is equivalent to 'foo(y, x=12)', see original 'foo' doc below.&gt;\n\n    a `foo` function\n\n    :param x:\n    :param y:\n    :return:\n</code></pre> <p>A <code>@with_partial</code> decorator is also available to create partial views easily for quick tests:</p> <pre><code>@with_partial(x=12)\ndef foo(x, y):\n    \"\"\"\n    a `foo` function\n\n    :param x:\n    :param y:\n    :return:\n    \"\"\"\n    return x + y\n</code></pre>"},{"location":"#to-inject-a-dynamically-baked-value","title":"To inject a dynamically baked value","text":"<p>As mentioned previously, <code>@wraps</code> provides a <code>remove_args</code> parameter where you can pass one or several argument names.</p> <pre><code>def inject_random_a(f):\n    \"\"\"\n    A decorator that injects a random number inside the `a` argument, \n    removing it from the exposed signature\n    \"\"\"\n    @wraps(f, remove_args='a')\n    def my_wrapper(*args, **kwargs):\n        # generate a random value for a and inject it in the args for f\n        kwargs['a'] = random()\n        return f(*args, **kwargs)\n\n    return my_wrapper\n\n@inject_random_a\ndef summer(a, b):\n    return a + b\n\nassert 12 &lt;= summer(b=12) &lt;= 13\n</code></pre>"},{"location":"#3-advanced-topics","title":"3- Advanced topics","text":""},{"location":"#generators-and-coroutines","title":"Generators and Coroutines","text":"<p><code>create_function</code> and <code>@with_signature</code> will automatically create a generator if your implementation is a generator:</p> <pre><code># define the implementation\ndef my_generator_impl(b, a=0):\n    for i in range(a, b):\n        yield i * i\n\n# create the dynamic function\ngen_func = create_function(\"foo(a, b)\", my_generator_impl)\n\n# verify that the new function is a generator and behaves as such\nassert isgeneratorfunction(gen_func)\nassert list(gen_func(1, 4)) == [1, 4, 9]\n</code></pre> <p>The same goes for generator-based coroutines:</p> <pre><code># define the impl that should be called\ndef my_gencoroutine_impl(first_msg):\n    second_msg = (yield first_msg)\n    yield second_msg\n\n# create the dynamic function\ngen_func = create_function(\"foo(first_msg='hello')\", my_gencoroutine_impl)\n\n# verify that the new func is a generator-based coroutine and behaves correctly\ncor = gen_func('hi')\nassert next(cor) == 'hi'\nassert cor.send('chaps') == 'chaps'\ncor.send('ola')  # raises StopIteration\n</code></pre> <p>and asyncio coroutines as well</p> <pre><code># define the impl that should be called\nasync def my_native_coroutine_impl(sleep_time):\n    await sleep(sleep_time)\n    return sleep_time\n\n# create the dynamic function\ngen_func = create_function(\"foo(sleep_time=2)\", my_native_coroutine_impl)\n\n# verify that the new function is a native coroutine and behaves correctly\nfrom asyncio import get_event_loop\nout = get_event_loop().run_until_complete(gen_func(5))\nassert out == 5\n</code></pre>"},{"location":"#generated-source-code","title":"Generated source code","text":"<p>The generated source code is in the <code>__source__</code> field of the generated function:</p> <pre><code>print(gen_func.__source__)\n</code></pre> <p>prints the following source code:</p> <pre><code>def foo(b, a=0):\n    return _func_impl_(b=b, a=a)\n</code></pre> <p>The <code>_func_impl_</code> symbol represents your implementation. As already mentioned, you see that the variables are passed to it as keyword arguments when possible (<code>_func_impl_(b=b)</code>, not simply <code>_func_impl_(b)</code>). Of course if it is not possible it adapts:</p> <pre><code>gen_func = create_function(\"foo(a=0, *args, **kwargs)\", func_impl)\nprint(gen_func.__source__)\n</code></pre> <p>prints the following source code:</p> <pre><code>def foo(a=0, *args, **kwargs):\n    return _func_impl_(a=a, *args, **kwargs)\n</code></pre>"},{"location":"#function-reference-injection","title":"Function reference injection","text":"<p>In some scenarios you may wish to share the same implementation among several created functions, for example to expose slightly different signatures on top of the same core.</p> <p>In that case you may wish your implementation to know from which dynamically generated function it is being called. For this, simply use <code>inject_as_first_arg=True</code>, and the called function will be injected as the first argument:</p> <pre><code>def core_impl(f, *args, **kwargs):\n    print(\"This is generic core called by %s\" % f.__name__)\n    # here you could use f.__name__ in a if statement to determine what to do\n    if f.__name__ == \"func1\":\n        print(\"called from func1 !\")\n    return args, kwargs\n\n# generate 2 functions\nfunc1 = create_function(\"func1(a, b)\", core_impl, inject_as_first_arg=True)\nfunc2 = create_function(\"func2(a, d)\", core_impl, inject_as_first_arg=True)\n\nfunc1(1, 2)\nfunc2(1, 2)\n</code></pre> <p>yields</p> <pre><code>This is generic core called by func1\ncalled from func1 !\nThis is generic core called by func2\n</code></pre>"},{"location":"#4-other-goodies","title":"4. Other goodies","text":""},{"location":"#compile_fun","title":"<code>@compile_fun</code>","text":"<p>A draft decorator to <code>compile</code> any existing function so that users cant debug through it. It can be handy to mask some code from your users for convenience (note that this does not provide any obfuscation, people can still reverse engineer your code easily. Actually the source code even gets copied in the function's <code>__source__</code> attribute for convenience):</p> <pre><code>from makefun import compile_fun\n\n@compile_fun\ndef foo(a, b):\n    return a + b\n\nassert foo(5, -5.0) == 0\nprint(foo.__source__)\n</code></pre> <p>yields</p> <pre><code>@compile_fun\ndef foo(a, b):\n    return a + b\n</code></pre> <p>If the function closure includes functions, they are recursively replaced with compiled versions too (only for this closure, this does not modify them otherwise). You may disable this behaviour entirely with <code>recurse=False</code>, or exclude some symbols from this recursion with the <code>except_names=(...)</code> arg (a tuple of names to exclude).</p> <p>IMPORTANT this decorator is a \"goodie\" in early stage and has not been extensively tested. Feel free to contribute !</p> <p>Note that according to this post compiling does not make the code run any faster.</p> <p>Known issues: <code>NameError</code> may appear if your function code depends on symbols that have not yet been defined. Make sure all symbols exist first ! See this issue.</p>"},{"location":"#main-features-benefits","title":"Main features / benefits","text":"<ul> <li>Generate functions with a dynamically defined signature: the signature can be provided as a string or as a <code>Signature</code> object, thus making it handy to derive from other functions.</li> <li>Implement them easily: the generated functions redirect their calls to the provided implementation function. As long as the signature is compliant, it will work as expected. For example the signature can be specific (<code>a: int, b=None</code>), and the implementation more generic (<code>*args, **kwargs</code>). Arguments will always be passed as keywords arguments when possible.</li> <li>Replace `@functools.wraps so that it correctly preserves signatures, and enable you to easily access named arguments.</li> </ul>"},{"location":"#see-also","title":"See Also","text":"<ul> <li>decorator, which largely inspired this code</li> <li>PEP362 - Function Signature Object </li> <li>A blog entry on dynamic function creation</li> <li>functools.wraps</li> </ul>"},{"location":"#others","title":"Others","text":"<p>Do you like this library ? You might also like my other python libraries </p>"},{"location":"#want-to-contribute","title":"Want to contribute ?","text":"<p>Details on the github page: https://github.com/smarie/python-makefun</p>"},{"location":"api_reference/","title":"API reference","text":"<p>In general, using <code>help(symbol)</code> is the recommended way to get the latest documentation. In addition, this page provides an overview of the various elements in this package.</p>"},{"location":"api_reference/#main-symbols","title":"Main symbols","text":""},{"location":"api_reference/#create_function","title":"<code>create_function</code>","text":"<pre><code>def create_function(func_signature: Union[str, Signature],\n                    func_impl: Callable[[Any], Any],\n                    func_name: str = None,\n                    inject_as_first_arg: bool = False,\n                    add_source: bool = True,\n                    add_impl: bool = True,\n                    doc: str = None,\n                    qualname: str = None,\n                    co_name: str = None,\n                    module_name: str = None,\n                    **attrs):\n</code></pre> <p>Creates a function with signature <code>func_signature</code> that will call <code>func_impl</code> when called. All arguments received by the generated function will be propagated as keyword-arguments to <code>func_impl</code> when it is possible (so all the time, except for var-positional or positional-only arguments that get passed as *args. Note that positional-only does not yet exist in python but this case is already covered because it is supported by <code>Signature</code> objects).</p> <p><code>func_signature</code> can be provided in different formats:</p> <ul> <li> <p>as a string containing the name and signature without 'def' keyword, such as <code>'foo(a, b: int, *args, **kwargs)'</code>. In which case the name in the string will be used for the <code>__name__</code> and <code>__qualname__</code> of the created function by default.</p> </li> <li> <p>as a <code>Signature</code> object, for example created using <code>signature(f)</code> or handcrafted. Since a <code>Signature</code> object does not contain any name, in this case the <code>__name__</code> and <code>__qualname__</code> of the created function will be copied from <code>func_impl</code> by default.</p> </li> </ul> <p>All the other metadata of the created function are defined as follows:</p> <ul> <li>default <code>__name__</code> attribute (see above) can be overridden by providing a non-None <code>func_name</code></li> <li>default <code>__qualname__</code> attribute (see above) can be overridden by providing a non-None <code>qualname</code></li> <li><code>__annotations__</code> attribute is created to match the annotations in the signature.</li> <li><code>__doc__</code> attribute is copied from <code>func_impl.__doc__</code> except if overridden using <code>doc</code></li> <li><code>__module__</code> attribute is copied from <code>func_impl.__module__</code> except if overridden using <code>module_name</code></li> <li><code>__code__.co_name</code> (see above) defaults to the same value as the above <code>__name__</code> attribute, except when that value is not a valid Python identifier, in which case it will be <code>&lt;lambda&gt;</code>. It can be  overridden by providing a <code>co_name</code> that is either a valid Python identifier or <code>&lt;lambda&gt;</code>.</li> </ul> <p>Finally two new attributes are optionally created</p> <ul> <li><code>__source__</code> attribute: set if <code>add_source</code> is <code>True</code> (default), this attribute contains the source code of the generated function</li> <li><code>__func_impl__</code> attribute: set if <code>add_impl</code> is <code>True</code> (default), this attribute contains a pointer to <code>func_impl</code></li> </ul> <p>A lambda function will be created in the following cases:</p> <ul> <li>when <code>func_signature</code> is a <code>Signature</code> object and <code>func_impl</code> is itself a lambda function,</li> <li>when the function name, either derived from a <code>func_signature</code> string, or given explicitly with <code>func_name</code>, is not a valid Python identifier, or</li> <li>when the provided <code>co_name</code> is <code>&lt;lambda&gt;</code>.</li> </ul> <p>Parameters:</p> <ul> <li> <p><code>func_signature</code>: either a string without 'def' such as \"foo(a, b: int, args, *kwargs)\" or \"(a, b: int)\", or a <code>Signature</code> object, for example from the output of <code>inspect.signature</code> or from the <code>funcsigs.signature</code> backport. Note that these objects can be created manually too. If the signature is provided as a string and contains a non-empty name, this name will be used instead of the one of the decorated function.</p> </li> <li> <p><code>func_impl</code>: the function that will be called when the generated function is executed. Its signature should be compliant with (=more generic than) <code>func_signature</code></p> </li> <li> <p><code>inject_as_first_arg</code>: if <code>True</code>, the created function will be injected as the first positional argument of <code>func_impl</code>. This can be handy in case the implementation is shared between several facades and needs to know from which context it was called. Default=<code>False</code></p> </li> <li> <p><code>func_name</code>: provide a non-<code>None</code> value to override the created function <code>__name__</code> and <code>__qualname__</code>. If this is <code>None</code> (default), the <code>__name__</code> will default to the one of <code>func_impl</code> if <code>func_signature</code> is a <code>Signature</code>, or to the name defined in <code>func_signature</code> if <code>func_signature</code> is a <code>str</code> and contains a non-empty name.</p> </li> <li> <p><code>add_source</code>: a boolean indicating if a 'source' annotation should be added to the generated function (default: True)</p> </li> <li> <p><code>add_impl</code>: a boolean indicating if a 'func_impl' annotation should be added to the generated function (default: True)</p> </li> <li> <p><code>doc</code>: a string representing the docstring that will be used to set the doc attribute on the generated function. If None (default), the doc of func_impl will be used.</p> </li> <li> <p><code>qualname</code>: a string representing the qualified name to be used. If None (default), the <code>__qualname__</code> will default to the one of <code>func_impl</code> if <code>func_signature</code> is a <code>Signature</code>, or to the name defined in <code>func_signature</code> if <code>func_signature</code> is a <code>str</code> and contains a non-empty name.</p> </li> <li> <p><code>co_name</code>: a string representing the name to be used in the compiled code of the function. If None (default), the <code>__code__.co_name</code> will default to the one of <code>func_impl</code> if <code>func_signature</code> is a <code>Signature</code>, or to the name defined in <code>func_signature</code> if <code>func_signature</code> is a <code>str</code> and contains a non-empty name.</p> </li> <li> <p><code>module_name</code>: the name of the module to be set on the function (under module ). If None (default), <code>func_impl.__module__</code> will be used.</p> </li> <li> <p><code>attrs</code>: other keyword attributes that should be set on the function. Note that <code>func_impl.__dict__</code> is not automatically copied.</p> </li> </ul>"},{"location":"api_reference/#with_signature","title":"<code>@with_signature</code>","text":"<pre><code>def with_signature(func_signature: Union[str, Signature],\n                   func_name: str = None,\n                   inject_as_first_arg: bool = False,\n                   add_source: bool = True,\n                   add_impl: bool = True,\n                   doc: str = None,\n                   qualname: str = None,\n                   co_name: str = None,\n                   module_name: str = None,\n                   **attrs\n                   ):\n</code></pre> <p>A decorator for functions, to change their signature. The new signature should be compliant with the old one.</p> <pre><code>@with_signature(&lt;arguments&gt;)\ndef impl(...):\n    ...\n</code></pre> <p>is totally equivalent to <code>impl = create_function(&lt;arguments&gt;, func_impl=impl)</code> except for one additional behaviour:</p> <ul> <li> <p>If <code>func_signature</code> is set to <code>None</code>, there is no <code>TypeError</code> as in create_function. Instead, this simply applies the new metadata (name, doc, module_name, attrs) to the decorated function without creating a wrapper. <code>add_source</code>, <code>add_impl</code> and <code>inject_as_first_arg</code> should not be set in this case.</p> </li> <li> <p><code>func_signature</code>: the new signature of the decorated function. Either a string without 'def' such as \"foo(a, b: int, args, *kwargs)\" or \"(a, b: int)\", or a <code>Signature</code> object, for example from the output of <code>inspect.signature</code> or from the <code>funcsigs.signature</code> backport. Note that these objects can be created manually too. If the signature is provided as a string and contains a non-empty name, this name will be used instead of the one of the decorated function. Finally <code>None</code> can be provided to indicate that user wants to only change the medatadata (func_name, doc, module_name, attrs) of the decorated function, without generating a new function.</p> </li> <li> <p><code>inject_as_first_arg</code>: if <code>True</code>, the created function will be injected as the first positional argument of <code>func_impl</code>. This can be handy in case the implementation is shared between several facades and needs to know from which context it was called. Default=<code>False</code></p> </li> <li> <p><code>func_name</code>: provide a non-<code>None</code> value to override the created function <code>__name__</code> and <code>__qualname__</code>. If this is <code>None</code> (default), the <code>__name__</code> will default to the one of <code>func_impl</code> if <code>func_signature</code> is a <code>Signature</code>, or to the name defined in <code>func_signature</code> if <code>func_signature</code> is a <code>str</code> and contains a non-empty name.</p> </li> <li> <p><code>add_source</code>: a boolean indicating if a 'source' annotation should be added to the generated function (default: True)</p> </li> <li> <p><code>add_impl</code>: a boolean indicating if a 'func_impl' annotation should be added to the generated function (default: True)</p> </li> <li> <p><code>doc</code>: a string representing the docstring that will be used to set the doc attribute on the generated function. If None (default), the doc of the decorated function will be used.</p> </li> <li> <p><code>qualname</code>: a string representing the qualified name to be used. If None (default), the <code>__qualname__</code> will default to the one of <code>func_impl</code> if <code>func_signature</code> is a <code>Signature</code>, or to the name defined in <code>func_signature</code> if <code>func_signature</code> is a <code>str</code> and contains a non-empty name.</p> </li> <li> <p><code>co_name</code>: a string representing the name to be used in the compiled code of the function. If None (default), the <code>__code__.co_name</code> will default to the one of <code>func_impl</code> if <code>func_signature</code> is a <code>Signature</code>, or to the name defined in <code>func_signature</code> if <code>func_signature</code> is a <code>str</code> and contains a non-empty name.</p> </li> <li> <p><code>module_name</code>: the name of the module to be set on the function (under module ). If None (default), the <code>__module__</code> attribute of the decorated function will be used.</p> </li> <li> <p><code>attrs</code>: other keyword attributes that should be set on the function. Note that the full <code>__dict__</code> of the decorated function is not automatically copied.</p> </li> </ul>"},{"location":"api_reference/#wraps","title":"<code>@wraps</code>","text":"<pre><code>def wraps(f,\n          new_sig: Union[str, Signature] = None,\n          prepend_args: Union[str, Parameter, Iterable[Union[str, Parameter]]] = None,\n          append_args: Union[str, Parameter, Iterable[Union[str, Parameter]]] = None,\n          remove_args: Union[str, Iterable[str]] = None,\n          func_name: str = None,\n          inject_as_first_arg: bool = False,\n          add_source: bool = True,\n          add_impl: bool = True,\n          doc: str = None,\n          qualname: str = None,\n          co_name: str = None,\n          module_name: str = None,\n          **attrs\n          ):\n</code></pre> <p>A decorator to create a signature-preserving wrapper function.</p> <p>It is similar to <code>functools.wraps</code>, but </p> <ul> <li> <p>relies on a proper dynamically-generated function. Therefore as opposed to <code>functools.wraps</code>, </p> <ul> <li>the wrapper body will not be executed if the arguments provided are not compliant with the signature - instead a <code>TypeError</code> will be raised before entering the wrapper body. </li> <li>the arguments will always be received as keywords by the wrapper, when possible. See documentation for details.</li> </ul> </li> <li> <p>you can modify the signature of the resulting function, by providing a new one with <code>new_sig</code> or by providing a list of arguments to remove in <code>remove_args</code>, to prepend in <code>prepend_args</code>, or to append in <code>append_args</code>. See documentation on full and quick signature edits for details.</p> </li> </ul> <p>Comparison with <code>@with_signature</code>: <code>@wraps(f)</code> is equivalent to</p> <pre><code>`@with_signature(signature(f),\n                 func_name=f.__name__,\n                 doc=f.__doc__,\n                 module_name=f.__module__,\n                 qualname=f.__qualname__,\n                 __wrapped__=f,\n                 **f.__dict__,\n                 **attrs)`\n</code></pre> <p>In other words, as opposed to <code>@with_signature</code>, the metadata (doc, module name, etc.) is provided by the wrapped <code>wrapped_fun</code>, so that the created function seems to be identical (except possiblyfor the signature). Note that all options in <code>with_signature</code> can still be overrided using parameters of <code>@wraps</code>.</p> <p>The additional <code>__wrapped__</code> attribute is added on the created function, to stay consistent with the <code>functools.wraps</code> behaviour. If the signature is modified through <code>new_sig</code>, <code>remove_args</code>, <code>append_args</code> or <code>prepend_args</code>, the <code>__signature__</code> attribute will be added per PEP 362.</p> <p>See also python documentation on @wraps</p> <p>Parameters</p> <ul> <li> <p><code>wrapped_fun</code>: the function that you intend to wrap with the decorated function. As in <code>functools.wraps</code>, <code>wrapped_fun</code> is used as the default reference for the exposed signature, <code>__name__</code>, <code>__qualname__</code>, <code>__doc__</code> and <code>__dict__</code>.</p> </li> <li> <p><code>new_sig</code>: the new signature of the decorated function. By default it is <code>None</code> and means \"same signature as in <code>wrapped_fun</code>\" (similar behaviour as in <code>functools.wraps</code>) If you wish to modify the exposed signature you can either use <code>remove/prepend/append_args</code>, or pass a non-None <code>new_sig</code>. It can be either a string without 'def' such as \"foo(a, b: int, args, *kwargs)\" of \"(a, b: int)\", or a <code>Signature</code> object, for example from the output of <code>inspect.signature</code> or from the <code>funcsigs.signature</code> backport. Note that these objects can be created manually too. If the signature is provided as a string and contains a non-empty name, this name will be used instead of the one of <code>wrapped_fun</code>.</p> </li> <li> <p><code>prepend_args</code>: a string or list of strings to prepend to the signature of <code>wrapped_fun</code>. These extra arguments should not be passed to <code>wrapped_fun</code>, as it does not know them. This is typically used to easily create a wrapper with additional arguments, without having to manipulate the signature objects.</p> </li> <li> <p><code>append_args</code>: a string or list of strings to append to the signature of <code>wrapped_fun</code>. These extra arguments should not be passed to <code>wrapped_fun</code>, as it does not know them. This is typically used to easily create a wrapper with additional arguments, without having to manipulate the signature objects.</p> </li> <li> <p><code>remove_args</code>: a string or list of strings to remove from the signature of <code>wrapped_fun</code>. These arguments should be injected in the received <code>kwargs</code> before calling <code>wrapped_fun</code>, as it requires them. This is typically used to easily create a wrapper with less arguments, without having to manipulate the signature objects.</p> </li> <li> <p><code>func_name</code>: provide a non-<code>None</code> value to override the created function <code>__name__</code> and <code>__qualname__</code>. If this is <code>None</code> (default), the <code>__name__</code> will default to the ones of <code>wrapped_fun</code> if <code>new_sig</code> is <code>None</code> or is a <code>Signature</code>, or to the name defined in <code>new_sig</code> if <code>new_sig</code> is a <code>str</code> and contains a non-empty name.</p> </li> <li> <p><code>inject_as_first_arg</code>: if <code>True</code>, the created function will be injected as the first positional argument of the decorated function. This can be handy in case the implementation is shared between several facades and needs to know from which context it was called. Default=<code>False</code></p> </li> <li> <p><code>add_source</code>: a boolean indicating if a 'source' annotation should be added to the generated function (default: True)</p> </li> <li> <p><code>add_impl</code>: a boolean indicating if a 'func_impl' annotation should be added to the generated function (default: True)</p> </li> <li> <p><code>doc</code>: a string representing the docstring that will be used to set the doc attribute on the generated function. If None (default), the doc of <code>wrapped_fun</code> will be used. If <code>wrapped_fun</code> is an instance of <code>functools.partial</code>, a special enhanced doc will be generated.</p> </li> <li> <p><code>qualname</code>: a string representing the qualified name to be used. If None (default), the <code>__qualname__</code> will default to the one of <code>wrapped_fun</code>, or the one in <code>new_sig</code> if <code>new_sig</code> is provided as a string with a non-empty function name.</p> </li> <li> <p><code>co_name</code>: a string representing the name to be used in the compiled code of the function. If None (default), the <code>__code__.co_name</code> will default to the one of <code>func_impl</code> if <code>func_signature</code> is a <code>Signature</code>, or to the name defined in <code>func_signature</code> if <code>func_signature</code> is a <code>str</code> and contains a non-empty name.</p> </li> <li> <p><code>module_name</code>: the name of the module to be set on the function (under module ). If None (default), the <code>__module__</code> attribute of <code>wrapped_fun</code> will be used.</p> </li> <li> <p><code>attrs</code>: other keyword attributes that should be set on the function. Note that the full <code>__dict__</code> of <code>wrapped_fun</code> is automatically copied.</p> </li> </ul>"},{"location":"api_reference/#create_wrapper","title":"<code>create_wrapper</code>","text":"<pre><code>def create_wrapper(wrapped,\n                   wrapper,\n                   new_sig: Union[str, Signature] = None,\n                   prepend_args: Union[str, Parameter, Iterable[Union[str, Parameter]]] = None,\n                   append_args: Union[str, Parameter, Iterable[Union[str, Parameter]]] = None,\n                   remove_args: Union[str, Iterable[str]] = None,\n                   func_name: str = None,\n                   inject_as_first_arg: bool = False,\n                   add_source: bool = True,\n                   add_impl: bool = True,\n                   doc: str = None,\n                   qualname: str = None,\n                   co_name: str = None,\n                   module_name: str = None,\n                   **attrs\n                   ):\n</code></pre> <p>Creates a signature-preserving wrapper function. <code>create_wrapper(wrapped, wrapper, **kwargs)</code> is equivalent to <code>wraps(wrapped, **kwargs)(wrapper)</code>. See <code>@wraps</code></p>"},{"location":"api_reference/#partial","title":"<code>@partial</code>","text":"<pre><code>def partial(f: Callable, \n            *preset_pos_args, \n            **preset_kwargs\n            ):\n</code></pre> <p>Equivalent of <code>functools.partial</code> but relies on a dynamically-created function. As a result the function looks nicer to users in terms of apparent documentation, name, etc.</p> <p>See documentation for details.</p>"},{"location":"api_reference/#with_partial","title":"<code>@with_partial</code>","text":"<pre><code>def with_partial(*preset_pos_args, \n                 **preset_kwargs\n                 ):\n</code></pre> <p>Decorator to 'partialize' a function using <code>partial</code>.</p>"},{"location":"api_reference/#signature-editing-utils","title":"Signature editing utils","text":""},{"location":"api_reference/#add_signature_parameters","title":"<code>add_signature_parameters</code>","text":"<pre><code>def add_signature_parameters(s,             # type: Signature\n                             first=(),      # type: Union[str, Parameter, Iterable[Union[str, Parameter]]]\n                             last=(),       # type: Union[str, Parameter, Iterable[Union[str, Parameter]]]\n                             custom=(),     # type: Union[Parameter, Iterable[Parameter]]\n                             custom_idx=-1  # type: int\n                             ):\n</code></pre> <p>Adds the provided parameters to the signature <code>s</code> (returns a new <code>Signature</code> instance).</p> <ul> <li><code>s</code>: the original signature to edit</li> <li><code>first</code>: a single element or a list of <code>Parameter</code> instances to be added at the beginning of the parameter's list. Strings can also be provided, in which case the parameter kind will be created based on best guess.</li> <li><code>last</code>: a single element or a list of <code>Parameter</code> instances to be added at the end of the parameter's list. Strings can also be provided, in which case the parameter kind will be created based on best guess.</li> <li><code>custom</code>: a single element or a list of <code>Parameter</code> instances to be added at a custom position in the list. That position is determined with <code>custom_idx</code></li> <li><code>custom_idx</code>: the custom position to insert the <code>custom</code> parameters to.</li> </ul>"},{"location":"api_reference/#remove_signature_parameters","title":"<code>remove_signature_parameters</code>","text":"<pre><code>def remove_signature_parameters(s, \n                                *param_names):\n</code></pre> <p>Removes the provided parameters from the signature <code>s</code> (returns a new <code>Signature</code> instance).</p>"},{"location":"api_reference/#pseudo-compilation","title":"Pseudo-compilation","text":""},{"location":"api_reference/#compile_fun","title":"<code>compile_fun</code>","text":""},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#1153-bugfix","title":"1.15.3 - bugfix","text":"<ul> <li>Fixed <code>SyntaxError: invalid syntax</code> happening when the default value of one argument of the created function is a     subclass of a basic primitive. Fixes #98. PR    #99 by moskupols.</li> </ul>"},{"location":"changelog/#1152-bugfix","title":"1.15.2 - bugfix","text":"<ul> <li>Fixed <code>SyntaxError</code> happening when the name of a native coroutine function to create contains <code>'return'</code>.    Fixes #96.</li> </ul>"},{"location":"changelog/#1151-bugfixes","title":"1.15.1 - bugfixes","text":"<ul> <li>Fixed <code>ValueError: Invalid co_name</code> happening on python 2 when the name of a function to create starts or ends with    <code>_</code> or contains a double <code>__</code> . Fixes #91</li> </ul>"},{"location":"changelog/#1150-more-pep-compliant-wraps","title":"1.15.0 - More PEP-compliant <code>wraps</code>","text":"<ul> <li><code>wraps</code> now always sets the <code>__wrapped__</code> attribute, and also sets the <code>__signature__</code> attribute when the signature changes, as specified by PEP 362. PR #86 by lucaswiman.</li> </ul>"},{"location":"changelog/#1140-support-for-lambda-functions","title":"1.14.0 - Support for lambda functions","text":"<ul> <li><code>create_wrapper</code>, <code>create_function</code>, <code>wraps</code> and <code>with_signature</code> now support lambda functions. They also accept a new parameter <code>co_name</code> to define the name to be used in the compiled code. PR #80 by andrewcleveland.</li> </ul>"},{"location":"changelog/#1131-fixed-regression-with-generators-in-python-35","title":"1.13.1 - Fixed regression with generators in python 3.5","text":"<ul> <li>Fixed an issue where using <code>partial</code> on a generator function in python 3.5 was raising a <code>SyntaxError</code>. Fixed #79</li> </ul>"},{"location":"changelog/#1130-support-for-async-generator-functions","title":"1.13.0 - Support for async generator functions","text":"<ul> <li>async generator functions are now supported (See PEP525). Fixed #77. PR#78 by broglep-work.</li> </ul>"},{"location":"changelog/#1121-bugfix","title":"1.12.1 - Bugfix","text":"<ul> <li>Fixed <code>TypeError</code> when a <code>func</code> attribute is present on the function provided to <code>create_function</code>. Fixed #76</li> </ul>"},{"location":"changelog/#1120-refactoring-and-consistency-improvement","title":"1.12.0 - Refactoring and consistency improvement","text":"<ul> <li>Fixed <code>partial</code> so that :</li> <li>when no argument is provided, it is equivalent to <code>wraps(f)(f)</code>. That is, the <code>__wrapped__</code> attribute is set. Fixed #73</li> <li>it sets the <code>func</code> attribute just as <code>functools.partial</code> does. Fixed #75 </li> <li>Removed <code>pytest-cases</code> dependency as it was a circular one. Fixed #68</li> <li>Now using <code>flake8</code> for qualimetry and <code>genbadge</code> for badges. Fixed #71</li> <li>Restructured project so that tests are truly independent, to ease rpm/apt/etc. packaging. Fixed #69</li> </ul>"},{"location":"changelog/#1113-bugfix-with-default-values-representable-but-not-evaluable","title":"1.11.3 - bugfix with default values representable but not evaluable","text":"<ul> <li>When a default value <code>v</code> in a signature is representable but its <code>eval(repr(v))</code> raises an exception, created signatures would raise an exception instead of automatically protecting the symbol. PR #67 by gcalmettes.</li> </ul>"},{"location":"changelog/#1112-bugfix-with-chained-wraps","title":"1.11.2 - bugfix with chained <code>@wraps</code>","text":"<ul> <li>Fixed issue where <code>@wraps</code> does not remove the <code>__wrapped__</code> attribute when it wraps an already-wrapped function, and modifies its signature. Fixes #66</li> </ul>"},{"location":"changelog/#1111-bugfix","title":"1.11.1 - bugfix","text":"<ul> <li>Fixed a bug happening when trying to generate a function where <code>float('inf')</code> is used as a default value. Fixes #63.</li> </ul>"},{"location":"changelog/#1110-partial-bugfixes-and-improvements-new-wraps-parameters","title":"1.11.0 - <code>partial</code> bugfixes and improvements + new <code>wraps</code> parameters","text":"<ul> <li> <p><code>@wraps</code> now has new arguments <code>prepend_arg</code> and <code>append_arg</code> to quickly prepend or append a new parameter to a function signature. Fixes #65</p> </li> <li> <p><code>add_signature_parameters</code> can now receive string parameter names in its <code>first</code> and <code>last</code> arguments.</p> </li> <li> <p>Improved generated docstring for <code>partial</code> with better support for preset positional args.</p> </li> <li> <p><code>partial</code>'s behaviour is now aligned with the one in <code>functools.partial</code> in terms of arguments order and kind. Fixes #64</p> </li> <li> <p>Bug fix: passing preset positional arguments to <code>partial</code> does not wipe out the rest of the signature any more. Fixes #62</p> </li> </ul>"},{"location":"changelog/#1102-github-actions-test","title":"1.10.2 - Github actions test","text":"<ul> <li>Technical release: validation of the new github actions workflow.</li> </ul>"},{"location":"changelog/#1101-github-actions-migration","title":"1.10.1 - Github actions migration","text":"<ul> <li>Technical release: validation of the new github actions workflow for PyPi deployment.</li> </ul>"},{"location":"changelog/#1100-removing-arguments-easily-in-wraps","title":"1.10.0 - Removing arguments easily in <code>@wraps</code>","text":"<ul> <li><code>@wraps</code> now offers a <code>remove_params</code> argument allowing one to remove an argument from the exposed signature, typically to create and inject it in the wrapper. Fixes #60</li> </ul>"},{"location":"changelog/#195-bugfix-with-partial-when-f-has-no-args","title":"1.9.5 - Bugfix with <code>partial</code> when f has no args","text":"<ul> <li><code>partial</code> can now be used to create a copy of a function with no args. Fixed <code>ValueError: Cannot preset 0 positional args, function case_second has only 0 args.</code>. Fixed #59</li> </ul>"},{"location":"changelog/#194-removed-six-dependency","title":"1.9.4 - removed six dependency","text":"<ul> <li>Removed unused <code>six</code> dependency. Note: this version will ship in conda forge.</li> </ul>"},{"location":"changelog/#193-minor-compatibility-fixes-with-functoolspartial","title":"1.9.3 - Minor compatibility fixes with functools.partial","text":"<ul> <li> <p><code>@wraps</code> can now be used to wrap a <code>functools.partial</code>. Fixed #57</p> </li> <li> <p><code>create_function</code> now correctly reuses information from the partialized function if a <code>functools.partial</code> is used as the implementation.</p> </li> <li> <p><code>create_function</code> now raises a more explicit error when no <code>func_name</code> can be found.</p> </li> <li> <p><code>makefun.partial</code> now generates a signature that is more consistent with <code>functools.partial</code>. Fixes #58</p> </li> </ul>"},{"location":"changelog/#192-packaging-improvements","title":"1.9.2 - packaging improvements","text":"<ul> <li>packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the <code>setup.py</code>. In particular removed dependency to <code>six</code> for setup and added <code>py.typed</code> file, as well as set the <code>zip_safe</code> flag to False. Removed tests folder from package. Fixes #54</li> </ul>"},{"location":"changelog/#191-compile_fun-bugfix","title":"1.9.1 - <code>@compile_fun</code> bugfix","text":"<p>Fixed <code>OSError: could not get source code</code> or <code>IOError: could not get source code</code> when <code>@compile_fun</code> is used on a function that depends on an already-compiled function. Fixed #51</p>"},{"location":"changelog/#190-compile_fun-improvements-bugfix-and-better-exception","title":"1.9.0 - <code>@compile_fun</code> improvements, bugfix and better exception","text":"<p><code>@compile_fun</code>: added capability to disable recursive compilation (<code>recurse</code> arg) , and to exclude some names from compilation (<code>except_names</code> arg). Fixed #49 and #50</p> <p>Fixed issue <code>ValueError: Cell is empty</code> with <code>@compile_fun</code>. Fixed #48</p> <p>Now raising an <code>UndefinedSymbolError</code> when a symbol is not known at compilation time. One step towards #47</p>"},{"location":"changelog/#180-new-compile_fun-goodie","title":"1.8.0 - new <code>@compile_fun</code> goodie","text":"<p>New goodie <code>@compile_fun</code> decorator to <code>compile</code> a function so that it can not be navigated to using the debugger. Fixes #46</p>"},{"location":"changelog/#170-minor-goodies-update","title":"1.7.0 - minor goodies update","text":"<p><code>add_signature_parameters</code> now accepts that one specifies a custom index where to insert the new parameters.</p>"},{"location":"changelog/#1611-added-version-attribute","title":"1.6.11 - Added version attribute","text":"<p>Added <code>__version__</code> attribute to comply with PEP396, following this guide. Fixes #45.</p>"},{"location":"changelog/#1610-fixed-dependencies-2","title":"1.6.10 - Fixed dependencies 2","text":"<p>Fixed <code>six</code> dependency: also declared as a setup dependency.</p>"},{"location":"changelog/#169-fixed-dependencies","title":"1.6.9 - Fixed dependencies","text":"<p>Added missing <code>six</code> dependency explicitly.</p>"},{"location":"changelog/#168-improved-performance","title":"1.6.8 - Improved performance","text":"<ul> <li>Improved performance of inner method <code>get_signature_string</code> (used by all entry points) after profiling.</li> </ul>"},{"location":"changelog/#167-increased-tolerance-to-function-signatures-in-python-2","title":"1.6.7 - Increased tolerance to function signatures in python 2","text":"<ul> <li>In python 2 some libraries such as <code>attrs</code> can modify the annotations manually, making <code>signature</code> return a string representation that is not compliant with the language version. This raised a <code>SyntaxError</code> in previous versions. The new version silently removes all these annotations in python versions that do not support them. Fixes #39.</li> </ul>"},{"location":"changelog/#166-bug-fix","title":"1.6.6 - Bug fix","text":"<ul> <li>Fixed yet another nasty varpositional-related bug :). Fixes #38.</li> </ul>"},{"location":"changelog/#165-bug-fix","title":"1.6.5 - Bug fix","text":"<ul> <li>Fixed <code>NameError</code> in case of unknown symbols in type hints. Fixes #37.</li> </ul>"},{"location":"changelog/#164-bug-fix-and-minor-improvement","title":"1.6.4 - Bug fix and minor improvement","text":"<ul> <li> <p>Fixed PEP8 error in source code. Fixes #35.</p> </li> <li> <p>Now string signatures can contain a colon. Fixes #36</p> </li> </ul>"},{"location":"changelog/#163-bug-fix-with-type-hints-in-signature","title":"1.6.3 - Bug fix with type hints in signature","text":"<p>Fixed bug when the return type annotation of the function to create contains non-locally available type hints. Fixes #33.</p>"},{"location":"changelog/#162-bug-fix-with-type-hints-in-signature","title":"1.6.2 - Bug fix with type hints in signature","text":"<p>Fixed bug when the signature of the function to create contains non-locally available type hints. Fixes #32.</p>"},{"location":"changelog/#161-with_partial-and-partial-minor-bug-fix","title":"1.6.1 - <code>with_partial</code> and <code>partial</code> minor bug fix","text":"<p>Fixed <code>partial</code> to support missing and empty docstring. Fixes #31.</p>"},{"location":"changelog/#160-added-with_partial-and-partial","title":"1.6.0 - added <code>with_partial</code> and <code>partial</code>","text":"<p>New method <code>partial</code> that behaves like <code>functools.partial</code>, and equivalent decorator <code>@with_partial</code>. Fixes #30.</p>"},{"location":"changelog/#151-bug-fix","title":"1.5.1 - bug fix","text":"<p><code>add_signature_parameters</code> now correctly inserts parameters in the right order when they are prepended (using <code>first=</code>). Fixed #29.</p>"},{"location":"changelog/#150-major-refactoring-and-bugfixes","title":"1.5.0 - Major refactoring and bugfixes","text":"<p>Function creation API:</p> <ul> <li>renamed all <code>handler</code> into <code>impl</code> for clarity. Fixes #27.</li> <li>renamed <code>addsource</code> and <code>addhandler</code> arguments as <code>add_source</code> and <code>add_impl</code> respectively, for consistency</li> <li>signatures can not be provided as a callable anymore - that was far too confusing. If the reference signature is a callable, then use <code>@wraps</code> or <code>create_wrapper</code>, because that's probably what you want to do (= reuse not only the signature but also all metadata). Fixes #26.</li> <li>the function name is now optional in signatures provided as string.</li> <li>now setting <code>__qualname__</code> attribute</li> <li>default function name, qualname, doc and module name are the ones from <code>func_impl</code> in <code>create_function</code> and <code>@with_signature</code>, and are the ones from the wrapped function in <code>create_wrapper</code> and <code>@wraps</code> as intuitively expected. Fixes #28.</li> </ul> <p>Wrappers:</p> <ul> <li><code>@wraps</code> and <code>create_wrapper</code> now offer a <code>new_sig</code> argument. In that case the <code>__wrapped__</code> attribute is not set. Fixes #25.</li> <li><code>@wraps</code> and <code>create_wrapper</code> now correctly preserve the <code>__dict__</code> and other metadata from the wrapped item. Fixes #24</li> </ul>"},{"location":"changelog/#140-non-representable-default-values-are-now-handled-correctly","title":"1.4.0 - Non-representable default values are now handled correctly","text":"<p>When a non-representable default value was used in the signature to generate, the code failed with a <code>SyntaxError</code>. This case is now correctly handled, by storing the corresponding variable in the generated function's context. Fixes #23.</p>"},{"location":"changelog/#130-aliases-for-signature-preserving-wrapper-scenarios","title":"1.3.0 - Aliases for signature-preserving wrapper scenarios","text":"<ul> <li> <p>Now providing a <code>@wraps</code>, equivalent of <code>functools.wraps</code>; and a <code>create_wrapper</code> equivalent of <code>functools.update_wrapper</code>. Fixes #21</p> </li> <li> <p><code>@with_signature</code> now does not override the <code>__name__</code> when signature is provided as a function. Fixes #22</p> </li> <li> <p><code>add_signature_parameters</code> now accepts that parameters are provided as single elements (not necessarily iterables)</p> </li> <li> <p>Updated documentation</p> </li> </ul>"},{"location":"changelog/#120-with_signature-supports-none","title":"1.2.0 - <code>@with_signature</code> supports <code>None</code>","text":"<p><code>None</code> can be used as the desired signature of <code>@with_signature</code>. This indicated that the user does not want to create a new function but only wants to update the metadata. Fixes #20.</p>"},{"location":"changelog/#112-fixes","title":"1.1.2 - Fixes","text":"<p>Fixed <code>isgeneratorfunction</code> for old python versions, see decorator#63.</p> <p>Python&lt;3.3-specific function body is now not loaded at all if not needed.</p>"},{"location":"changelog/#111-with_signature-fix","title":"1.1.1 - <code>@with_signature</code> fix","text":"<p><code>inject_as_first_arg</code> was missing from <code>@with_signature</code>, added it. Fixed #18.</p>"},{"location":"changelog/#110-support-for-generators-and-coroutines","title":"1.1.0 - Support for generators and coroutines","text":"<p>Now <code>create_function</code> and <code>@with_signature</code> create the same kind of function than the handler. So if it is a generator, a generator-based coroutine, or an async coroutine, the generated function will adapt. Fixes #6.</p>"},{"location":"changelog/#102-fixed-with_signature","title":"1.0.2 - Fixed <code>@with_signature</code>","text":"<p>Now a string signature can be provided to <code>@with_signature</code> without problem. Fixed #17.</p>"},{"location":"changelog/#101-minor-fixed-pypi-doc","title":"1.0.1 - minor: fixed PyPi doc","text":""},{"location":"changelog/#100-new-parameters-new-goodie-and-bugfix","title":"1.0.0 - New parameters, new goodie, and bugfix","text":"<p><code>@with_signature</code> :</p> <ul> <li>now exposes all options of <code>create_function</code>. Fixed #12.</li> <li>now correctly sets the module name by default. Fixes #13</li> <li>now accepts <code>None</code> as the new <code>func_signature</code> to declare that the signature is identical to the decorated function. This can be handy to just change the docstring or module name of a function for example. Fixes #15</li> </ul> <p><code>create_function</code> and <code>@with_signature</code>:</p> <ul> <li>New <code>module_name</code> parameter to override the module name. Fixes #14</li> <li>the handler is now available as a field of the generated function (under <code>__func_impl__</code>). New <code>addhandler</code> parameter (default: True) controls this behaviour. Fixes #16</li> </ul> <p>Misc:</p> <ul> <li>New goodie to manipulate signatures: <code>add_signature_parameters</code>.</li> <li>Fixed dependencies for documentation auto-build.</li> </ul>"},{"location":"changelog/#050-new-helper-function-and-bugfix","title":"0.5.0 - New helper function, and bugfix","text":"<p>New helper function <code>remove_signature_parameters</code>.</p> <p>Fixed issue with <code>@with_signature</code> when argument is a <code>Signature</code>. Fixes #11 </p>"},{"location":"changelog/#040-new-with_signature-decorator-and-create_function-accepts-functions","title":"0.4.0 - New <code>@with_signature</code> decorator, and <code>create_function</code> accepts functions","text":"<p>New decorator <code>@with_signature</code> to change the signature of a callable. Fixes #3</p> <p><code>create_function</code> now accepts that a function be passed as a signature template. Fixes #10</p>"},{"location":"changelog/#030-ability-to-generate-functions-from-signature","title":"0.3.0 - Ability to generate functions from <code>Signature</code>","text":"<p>Functions can now be created from a <code>Signature</code> object, in addition to string signatures. This unlocks many useful use cases, among easily creating function wrappers. Note: the inner function that provides this feature is <code>get_signature_from_string</code>. Fixes #8</p> <p>Improved design by getting rid of the regular expression parser to check parameters definition. This assumes that the compiler will correctly raise exceptions when a string signature is not correct, and that <code>inspect.signature</code> or <code>funcsigs.signature</code> works correctly at detecting all the parameter kinds and annotations on the resulting function. It seems like a fair assumption... Fixes #9.</p>"},{"location":"changelog/#020-various-new-features-and-improvements","title":"0.2.0 - Various new features and improvements","text":"<p><code>create_function</code>:</p> <ul> <li> <p><code>create_function</code> does not require users to prepend <code>\"def \"</code> to the signature anymore. Fixed #5</p> </li> <li> <p>Return annotations are now supported. Fixes #4.</p> </li> <li> <p>Type hint as comments are supported but the generated function loses the annotations because <code>inspect.signature</code> loses the annotation too in that case. Fixes #7</p> </li> <li> <p>Variable-length arguments such as <code>*args</code> and <code>**kwargs</code> are now properly handled. Fixes #2</p> </li> <li> <p>Handler functions can now receive the dynamically created function as first argument, by using <code>create_function(func_signature, func_handler, inject_as_first_arg=True)</code>. Fixes #1</p> </li> <li> <p>Renamed <code>_call_</code> into <code>_func_impl_</code> in the generated code.</p> </li> </ul> <p>Misc:</p> <ul> <li>Added <code>pytest-cases</code> dependency for tests.</li> </ul>"},{"location":"changelog/#010-first-public-version","title":"0.1.0 - First public version","text":"<p>First version created, largely inspired by <code>decorator</code></p>"},{"location":"long_description/","title":"makefun","text":"<p>Small library to dynamically create python functions.</p> <p>The documentation for users is available here: https://smarie.github.io/python-makefun/</p> <p>A readme for developers is available here: https://github.com/smarie/python-makefun</p>"}]}